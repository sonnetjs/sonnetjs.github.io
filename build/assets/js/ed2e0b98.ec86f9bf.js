"use strict";(self.webpackChunksonnet_docs=self.webpackChunksonnet_docs||[]).push([[7066],{3004:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>r});var a=t(4848),i=t(8453);const o={slug:"call-stack-and-callback-queue-in-js",title:"Call Stack and Callback Queue in JS",authors:{name:"Talha Mujahid",title:"Software Engineer",url:"https://github.com/htmujahid",image_url:"https://avatars.githubusercontent.com/u/58030954?v=4"},tags:["javascript"]},c="Call Stack and Callback Queue in JS",s={permalink:"/blog/call-stack-and-callback-queue-in-js",editUrl:"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/19-call-stack-and-callback-queue-in-js.md",source:"@site/blog/javascript/19-call-stack-and-callback-queue-in-js.md",title:"Call Stack and Callback Queue in JS",description:"JavaScript is a single-threaded language, which means it can only perform one task at a time. However, it is capable of handling multiple tasks simultaneously using the concept of Call Stack. The Call Stack is a mechanism used by the JavaScript engine to keep track of function calls. When a function is called, it is added to the top of the Call Stack, and when it returns, it is removed from the stack.",date:"2024-05-15T13:15:30.781Z",tags:[{label:"javascript",permalink:"/blog/tags/javascript"}],readingTime:3.86,hasTruncateMarker:!0,authors:[{name:"Talha Mujahid",title:"Software Engineer",url:"https://github.com/htmujahid",image_url:"https://avatars.githubusercontent.com/u/58030954?v=4",imageURL:"https://avatars.githubusercontent.com/u/58030954?v=4"}],frontMatter:{slug:"call-stack-and-callback-queue-in-js",title:"Call Stack and Callback Queue in JS",authors:{name:"Talha Mujahid",title:"Software Engineer",url:"https://github.com/htmujahid",image_url:"https://avatars.githubusercontent.com/u/58030954?v=4",imageURL:"https://avatars.githubusercontent.com/u/58030954?v=4"},tags:["javascript"]},unlisted:!1,prevItem:{title:"Iterator, Generator and Closure in JS",permalink:"/blog/iterator-generator-and-closure-in-js"},nextItem:{title:"Asynchronous Programming in JS",permalink:"/blog/asynchronous-programming-in-js"}},l={authorsImageUrls:[void 0]},r=[];function u(e){const n={code:"code",h1:"h1",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"JavaScript is a single-threaded language, which means it can only perform one task at a time. However, it is capable of handling multiple tasks simultaneously using the concept of Call Stack. The Call Stack is a mechanism used by the JavaScript engine to keep track of function calls. When a function is called, it is added to the top of the Call Stack, and when it returns, it is removed from the stack."}),"\n",(0,a.jsx)(n.h1,{id:"call-stack",children:"Call Stack"}),"\n",(0,a.jsx)(n.p,{children:"Consider the following code example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'function firstFunction() {  \n  console.log("This is the first function.");  \n}  \nfunction secondFunction() {  \n  firstFunction();  \n  console.log("This is the second function.");  \n}  \nsecondFunction();\n'})}),"\n",(0,a.jsxs)(n.p,{children:["When ",(0,a.jsx)(n.code,{children:"secondFunction()"})," is called, it first calls ",(0,a.jsx)(n.code,{children:"firstFunction()"}),", which is added to the top of the Call Stack. Once ",(0,a.jsx)(n.code,{children:"firstFunction()"})," completes its execution, it is removed from the stack, and ",(0,a.jsx)(n.code,{children:"secondFunction()"})," continues its execution, adding itself to the top of the stack. Finally, when ",(0,a.jsx)(n.code,{children:"secondFunction()"})," completes its execution, it is removed from the stack."]}),"\n",(0,a.jsx)(n.h1,{id:"recursion",children:"Recursion"}),"\n",(0,a.jsx)(n.p,{children:"Recursion is a powerful programming technique that can be used to solve complex problems. Recursion is a technique in programming where a function calls itself repeatedly until it reaches a base condition. Recursion is an essential concept in JavaScript and is widely used in various programming scenarios."}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Direct Recursion"}),": This is the most common type of recursion, in which a function calls itself directly."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"function factorial(n) {  \n  if (n === 0) {  \n    return 1;  \n  } else {  \n    return n * factorial(n - 1);  \n  }  \n}  \nconsole.log(factorial(5));\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Indirect Recursion"}),": In this type of recursion, multiple functions call each other in a circular manner."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"function fib1(num) {  \n  if (num <= 1) {  \n    return num;  \n  } else {  \n    return fib2(num - 1) + fib1(num - 2);  \n  }  \n}  \nfunction fib2(num) {  \n  if (num <= 1) {  \n    return num;  \n  } else {  \n    return fib1(num - 1) + fib2(num - 2);  \n  }  \n}  \nconsole.log(fib1(6)); // 8\n"})}),"\n",(0,a.jsx)(n.p,{children:"Recursion should be used with caution, as it can lead to stack overflow errors if not implemented correctly."}),"\n",(0,a.jsx)(n.h1,{id:"callback-queue",children:"Callback Queue"}),"\n",(0,a.jsx)(n.p,{children:"The Callback Queue is a data structure that holds a queue of functions to be executed. When a function is invoked and its operation is asynchronous, it is added to the Callback Queue instead of blocking the execution of other code. This means that while the asynchronous operation is in progress, other code can continue to execute without interruption."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'// Example of adding a function to the Callback Queue  \nsetTimeout(function(){  \n  console.log("This function is added to the Callback Queue");  \n}, 0);\n'})}),"\n",(0,a.jsx)(n.p,{children:"The Callback Queue maintains the order in which the functions are added. The first function to be added to the queue will be the first to be executed when the Call Stack is empty. This ensures that the functions are executed in the order they were added to the Callback Queue."}),"\n",(0,a.jsx)(n.h1,{id:"event-loop",children:"Event Loop"}),"\n",(0,a.jsx)(n.p,{children:"The Event Loop is a process that constantly checks the Callback Queue for functions to execute. If the Call Stack is empty, it dequeues the first function in the Callback Queue and adds it to the Call Stack for execution."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'// Example of the Event Loop  \nfunction firstFunction(){  \n  console.log("This is the first function");  \n  setTimeout(function(){  \n    console.log("This is the second function");  \n  }, 0);  \n  console.log("This is the third function");  \n}  \nfirstFunction();\n'})}),"\n",(0,a.jsx)(n.p,{children:"The Call Stack is a data structure that keeps track of the functions that are currently being executed. When a function is called, it is added to the Call Stack. When a function completes its execution, it is removed from the Call Stack."}),"\n",(0,a.jsx)(n.h1,{id:"how-they-work-together",children:"How they work together"}),"\n",(0,a.jsx)(n.p,{children:"When an asynchronous operation is triggered, a function (the callback function) is added to the Callback Queue. The Event Loop constantly checks the Callback Queue for the next function to execute. Once the Call Stack is emptied, the Event Loop dequeues the first function in the Callback Queue and adds it to the Call Stack for execution."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'// Example of how the Callback Queue and Event Loop work together  \nconsole.log("Start");  \nsetTimeout(function() {  \n  console.log("This is the first function");  \n}, 3000);  \nsetTimeout(function() {  \n  console.log("This is the second function");  \n}, 1000);  \nconsole.log("End");\n'})}),"\n",(0,a.jsx)(n.p,{children:"This allows JavaScript to handle asynchronous operations without blocking the execution of other code."}),"\n",(0,a.jsx)(n.p,{children:"In conclusion, the Call Stack is used to keep track of function calls, while Recursion is a technique in programming where a function calls itself repeatedly. The Callback Queue is a data structure that holds a queue of functions to be executed, while the Event Loop is a process that constantly checks the Callback Queue for functions to execute. These concepts allow JavaScript to handle multiple tasks simultaneously without blocking the execution of other code."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>s});var a=t(6540);const i={},o=a.createContext(i);function c(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);