"use strict";(self.webpackChunksonnet_docs=self.webpackChunksonnet_docs||[]).push([[7992],{2996:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>c,metadata:()=>r,toc:()=>d});var t=o(4848),i=o(8453);const c={sidebar_position:3},s="Lifecycle",r={id:"core/component/lifecycle",title:"Lifecycle",description:"Sonnet JS components lifecycle is bit different from other frameworks. There are not typical lifecycle methods like componentDidMount, componentDidUpdate, etc. Instead, Sonnet JS handles all this stuff in a different way. In Sonnet JS, lifecycle is maintained at app level instead of component level. What it means is that component is rendered (mounted) only once (single page environment). As long as the page is not changed, the component will not be re-rendered. This is the reason why there is no need for lifecycle methods like componentDidMount, componentDidUpdate, etc.",source:"@site/docs/core/component/lifecycle.md",sourceDirName:"core/component",slug:"/core/component/lifecycle",permalink:"/docs/core/component/lifecycle",draft:!1,unlisted:!1,editUrl:"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/docs/core/component/lifecycle.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"docSidebar",previous:{title:"Props",permalink:"/docs/core/component/props"},next:{title:"Application",permalink:"/docs/core/application"}},l={},d=[];function a(e){const n={code:"code",h1:"h1",li:"li",ol:"ol",p:"p",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"lifecycle",children:"Lifecycle"}),"\n",(0,t.jsxs)(n.p,{children:["Sonnet JS components lifecycle is bit different from other frameworks. There are not typical lifecycle methods like ",(0,t.jsx)(n.code,{children:"componentDidMount"}),", ",(0,t.jsx)(n.code,{children:"componentDidUpdate"}),", etc. Instead, Sonnet JS handles all this stuff in a different way. In Sonnet JS, lifecycle is maintained at app level instead of component level. What it means is that component is rendered (mounted) only once (single page environment). As long as the page is not changed, the component will not be re-rendered. This is the reason why there is no need for lifecycle methods like ",(0,t.jsx)(n.code,{children:"componentDidMount"}),", ",(0,t.jsx)(n.code,{children:"componentDidUpdate"}),", etc."]}),"\n",(0,t.jsx)(n.p,{children:"However, there is an order in which different methods are called when a component is rendered. This order is as follows:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"constructor"})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"get"})," (avoid using browser apis in get method)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"head"})," (static)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"head"})," (dynamic)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"script"})," (static)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"script"})," (dynamic)"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>s,x:()=>r});var t=o(6540);const i={},c=t.createContext(i);function s(e){const n=t.useContext(c);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(c.Provider,{value:n},e.children)}}}]);