"use strict";(self.webpackChunksonnet_docs=self.webpackChunksonnet_docs||[]).push([[4558],{8280:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>l});var t=a(4848),o=a(8453);const i={slug:"asynchronous-programming-in-js",title:"Asynchronous Programming in JS",authors:{name:"Talha Mujahid",title:"Software Engineer",url:"https://github.com/htmujahid",image_url:"https://avatars.githubusercontent.com/u/58030954?v=4"},tags:["javascript"]},s="Asynchronous Programming in JS",r={permalink:"/blog/asynchronous-programming-in-js",editUrl:"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/18-asynchronous-programming-in-js.md",source:"@site/blog/javascript/18-asynchronous-programming-in-js.md",title:"Asynchronous Programming in JS",description:"Asynchronous programming is a way of writing non-blocking code in JavaScript. In traditional programming, code runs sequentially from top to bottom, which means that one line of code is executed at a time. However, when dealing with long-running tasks such as network requests or file I/O, synchronous programming can lead to unresponsive applications.",date:"2024-05-15T13:15:30.761Z",tags:[{label:"javascript",permalink:"/blog/tags/javascript"}],readingTime:5.885,hasTruncateMarker:!0,authors:[{name:"Talha Mujahid",title:"Software Engineer",url:"https://github.com/htmujahid",image_url:"https://avatars.githubusercontent.com/u/58030954?v=4",imageURL:"https://avatars.githubusercontent.com/u/58030954?v=4"}],frontMatter:{slug:"asynchronous-programming-in-js",title:"Asynchronous Programming in JS",authors:{name:"Talha Mujahid",title:"Software Engineer",url:"https://github.com/htmujahid",image_url:"https://avatars.githubusercontent.com/u/58030954?v=4",imageURL:"https://avatars.githubusercontent.com/u/58030954?v=4"},tags:["javascript"]},unlisted:!1,prevItem:{title:"Call Stack and Callback Queue in JS",permalink:"/blog/call-stack-and-callback-queue-in-js"},nextItem:{title:"Scheduling in JS",permalink:"/blog/scheduling-in-js"}},c={authorsImageUrls:[void 0]},l=[];function h(e){const n={code:"code",h1:"h1",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Asynchronous programming is a way of writing non-blocking code in JavaScript. In traditional programming, code runs sequentially from top to bottom, which means that one line of code is executed at a time. However, when dealing with long-running tasks such as network requests or file I/O, synchronous programming can lead to unresponsive applications."}),"\n",(0,t.jsx)(n.h1,{id:"background",children:"Background"}),"\n",(0,t.jsx)(n.p,{children:"Asynchronous programming is necessary in JavaScript for several reasons, especially when it comes to web development."}),"\n",(0,t.jsx)(n.p,{children:"Firstly, many web applications need to perform I/O operations, such as reading and writing data to databases or making HTTP requests to external APIs. These operations can take a long time to complete, especially if the network connection is slow or the server is under heavy load. If we execute these operations synchronously, they will block the main thread of execution, making the entire application unresponsive until the operation is complete. Asynchronous programming allows us to execute these operations in the background, without blocking the main thread, making the application more responsive and performant."}),"\n",(0,t.jsx)(n.p,{children:"Secondly, JavaScript runs on a single thread, which means that it can only execute one task at a time. Asynchronous programming allows us to break up long-running tasks into smaller, asynchronous tasks, which can be executed simultaneously. For example, we can load several images in the background while the main thread is handling user input. This approach makes the application appear more responsive and improves the user experience."}),"\n",(0,t.jsx)(n.p,{children:"Finally, JavaScript is frequently used to build real-time applications, such as chat applications or online multiplayer games. In these applications, it is essential to update the UI in real-time, based on data received from the server. Asynchronous programming allows us to receive and process data in the background, without blocking the main thread, and then update the UI when the data is ready. This approach enables real-time updates and improves the overall user experience."}),"\n",(0,t.jsx)(n.p,{children:"In asynchronous programming, we execute tasks without blocking the main thread of execution, allowing for multiple tasks to run simultaneously. JavaScript provides several mechanisms for implementing asynchronous programming, including callbacks, promises, and the newer async/await syntax."}),"\n",(0,t.jsx)(n.h1,{id:"callback",children:"Callback"}),"\n",(0,t.jsx)(n.p,{children:"Callbacks are the oldest mechanism for implementing asynchronous programming in JavaScript. They are functions that are passed as arguments to other functions and executed once a particular task is complete. Callbacks allow developers to handle asynchronous operations by providing a way to execute code once a particular task has finished. However, as the complexity of the codebase increases, callbacks can become challenging to manage, leading to callback hell, where the code becomes nested and difficult to read."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"function add(a, b) {  \n  return a + b;  \n}  \nfunction multiply(a, b, callback) {  \n  const result = callback(a, b);  \n  console.log(result);  \n}  \nmultiply(3, 4, add); // Output: 7\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"setTimeOut"})," is an asynchronous function which creates a separate thread to perform function which is happening inside callback of this function."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'function fetchData(callback) {  \n  // Simulate a delay of 2 seconds (2000 milliseconds)  \n  setTimeout(function() {  \n    const data = {  \n      name: "John Doe",  \n      age: 30,  \n      city: "New York"  \n    };  \n    callback(data);  \n  }, 2000);  \nconsole.log("Fetching data...");  \n}  \nfunction displayData(data) {  \n  // Log the data to the console  \n  console.log(data);  \n}  \n// Fetch the data and display it using the displayData callback function  \nfetchData(displayData);  \n// Fetching data...  \n// {name: "John Doe", age: 30, city: "New York"}\n'})}),"\n",(0,t.jsx)(n.h1,{id:"callback-hell",children:"Callback Hell"}),"\n",(0,t.jsx)(n.p,{children:"Callback hell is a term used to describe deeply nested and difficult-to-read code that arises from using multiple levels of callbacks in JavaScript. Here\u2019s an example of callback hell:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"function operation1(callback1) {  \n  // First level of nesting  \n  setTimeout(function() {  \n    console.log('Operation 1');  \n    callback1();  \n  }, 1000);  \n}  \nfunction operation2(callback2) {  \n  // Second level of nesting  \n  setTimeout(function() {  \n    console.log('Operation 2');  \n    callback2();  \n  }, 1000);  \n}  \nfunction operation3(callback3) {  \n  // Third level of nesting  \n  setTimeout(function() {  \n    console.log('Operation 3');  \n    callback3();  \n  }, 1000);  \n}  \noperation1(function() {  \n  operation2(function() {  \n    operation3(function() {  \n      console.log('All operations completed!');  \n    });  \n  });  \n});\n"})}),"\n",(0,t.jsx)(n.h1,{id:"promise",children:"Promise"}),"\n",(0,t.jsx)(n.p,{children:"Promises were introduced in ECMAScript 6 as an alternative to callbacks. A promise is an object representing the eventual completion or failure of an asynchronous operation. They provide a more flexible and expressive way to write asynchronous code than callbacks, as they allow developers to chain multiple asynchronous operations and handle errors in a more structured and easy-to-read manner. Promises are easier to manage than callbacks, but they still require a fair amount of boilerplate code."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'function fetchData() {  \n  return new Promise(function(resolve, reject) {  \n    // Simulate a delay of 2 seconds (2000 milliseconds)  \n    setTimeout(function() {  \n      const data = {  \n        name: "John Doe",  \n        age: 30,  \n        city: "New York"  \n      };  \nif (data) {  \n        resolve(data);  \n      } else {  \n        reject("Error fetching data.");  \n      }  \n    }, 2000);  \n  });  \n}  \nfetchData()  \n  .then(function(data) {  \n    console.log(data);  \n  })  \n  .catch(function(error) {  \n    console.log(error);  \n  });\n'})}),"\n",(0,t.jsx)(n.h1,{id:"promise-chaining",children:"Promise Chaining"}),"\n",(0,t.jsxs)(n.p,{children:["Promise chaining is a technique for managing multiple asynchronous operations in a specific order using Promises. It involves returning a Promise from a ",(0,t.jsx)(n.code,{children:"**then()**"})," callback function, which can then be chained with another ",(0,t.jsx)(n.code,{children:"**then()**"})," function."]}),"\n",(0,t.jsxs)(n.p,{children:["When chaining Promises, each ",(0,t.jsx)(n.code,{children:"**then()**"})," callback function is executed after the previous Promise has resolved. The result of the previous Promise is passed as an argument to the ",(0,t.jsx)(n.code,{children:"**then()**"})," callback function, which can then return a new Promise to continue the chain."]}),"\n",(0,t.jsx)(n.p,{children:"By chaining Promises together, we can perform a series of asynchronous operations in a specific order, without having to nest multiple callback functions within each other (known as \u201ccallback hell\u201d). This makes the code easier to read and maintain."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'function fetchUserData() {  \n  return new Promise(function(resolve, reject) {  \n    setTimeout(function() {  \n      const userData = {  \n        name: "John Doe",  \n        age: 30,  \n        city: "New York"  \n      };  \nif (userData) {  \n        resolve(userData);  \n      } else {  \n        reject("Error fetching user data.");  \n      }  \n    }, 2000);  \n  });  \n}  \nfunction fetchOrdersData(userId) {  \n  return new Promise(function(resolve, reject) {  \n    setTimeout(function() {  \n      const ordersData = {  \n        id: "123456",  \n        userId: userId,  \n        items: ["item1", "item2", "item3"],  \n        totalPrice: 100  \n      };  \n      if (ordersData) {  \n        resolve(ordersData);  \n      } else {  \n        reject("Error fetching orders data.");  \n      }  \n    }, 2000);  \n  });  \n}  \nfetchUserData()  \n  .then(function(userData) {  \n    console.log(userData);  \n    return fetchOrdersData(userData.id);  \n  })  \n  .then(function(ordersData) {  \n    console.log(ordersData);  \n  })  \n  .catch(function(error) {  \n    console.log(error);  \n  });\n'})}),"\n",(0,t.jsxs)(n.h1,{id:"async--await",children:[(0,t.jsx)(n.code,{children:"async"})," / ",(0,t.jsx)(n.code,{children:"await"})]}),"\n",(0,t.jsxs)(n.p,{children:["The async/await syntax, introduced in ECMAScript 2017, provides a cleaner and more concise way of working with promises. Async/await is built on top of promises, and it allows developers to write asynchronous code that looks more like synchronous code. Async/await uses the keywords ",(0,t.jsx)(n.code,{children:"**async**"})," and ",(0,t.jsx)(n.code,{children:"**await**"})," to manage promises, making it easier to handle errors and write cleaner code. It is quickly becoming the preferred way of handling asynchronous programming in JavaScript."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'function fetchData() {  \n  return new Promise(function(resolve, reject) {  \n    // Simulate a delay of 2 seconds (2000 milliseconds)  \n    setTimeout(function() {  \n      const data = {  \n        name: "John Doe",  \n        age: 30,  \n        city: "New York"  \n      };  \nif (data) {  \n        resolve(data);  \n      } else {  \n        reject("Error fetching data.");  \n      }  \n    }, 2000);  \n  });  \n}  \nasync function getData() {  \n  try {  \n    const data = await fetchData();  \n    console.log(data);  \n  } catch (error) {  \n    console.log(error);  \n  }  \n}  \ngetData();\n'})}),"\n",(0,t.jsx)(n.p,{children:"In conclusion, asynchronous programming is a powerful technique that allows JavaScript to handle long-running tasks without disrupting the user experience. By using callbacks, promises, and async/await, developers can write more efficient and maintainable code, resulting in better performing applications."})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>s,x:()=>r});var t=a(6540);const o={},i=t.createContext(o);function s(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);