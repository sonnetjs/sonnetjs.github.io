{"archive":{"blogPosts":[{"id":"introduction-to-js","metadata":{"permalink":"/blog/introduction-to-js","editUrl":"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/0-introduction-to-js.md","source":"@site/blog/javascript/0-introduction-to-js.md","title":"Introduction to JavaScript","description":"JavaScript is one of the most popular programming languages in the world, and for good reason. It is a powerful language that can be used to create dynamic and interactive web pages. In this blog post, we will take an overview of complete language","date":"2024-05-16T10:39:22.000Z","tags":[{"label":"javascript","permalink":"/blog/tags/javascript"}],"readingTime":3.455,"hasTruncateMarker":true,"authors":[{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"}],"frontMatter":{"slug":"introduction-to-js","title":"Introduction to JavaScript","authors":{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"},"tags":["javascript"]},"unlisted":false,"nextItem":{"title":"Variables in JS: var, let, const","permalink":"/blog/variables-in-js-var-let-const"}},"content":"JavaScript is one of the most popular programming languages in the world, and for good reason. It is a powerful language that can be used to create dynamic and interactive web pages. In this blog post, we will take an overview of complete language\r\n<!-- truncate -->\r\n\r\n## History\r\n\r\nJavaScript was created by Brendan Eich in just 10 days in May 1995, while he was working at Netscape Communications Corporation. It was originally called Mocha, but was later renamed to LiveScript and finally JavaScript. The language was created to add interactivity to static HTML pages, which was a revolutionary concept at the time.\r\n\r\nIn 1996, Microsoft created JScript, which was essentially a clone of JavaScript. This led to a period of intense competition between Netscape and Microsoft, with both companies adding new features to their respective languages. This competition ultimately led to the creation of ECMAScript, which is a standardized version of JavaScript that is maintained by the European Computer Manufacturers Association (ECMA).\r\n\r\nOver the years, JavaScript has continued to evolve, with new features and capabilities being added to the language. Today, JavaScript is a full-fledged programming language that can be used for both client-side and server-side programming. It is a critical component of modern web development, and is used by developers all over the world to create dynamic and interactive web applications.\r\n\r\n## JS Compilation Steps\r\n\r\nThe process of converting JavaScript source code into bytecode involves several steps. Firstly, the JavaScript engine parses the source code and generates an Abstract Syntax Tree (AST) that represents the structure of the code. Next, the engine compiles the AST into bytecode, which is a lower-level representation of the code that can be executed by the engine. The bytecode is then optimized by the engine using various techniques, such as Just-In-Time (JIT) compilation, to improve the performance of the code. Finally, the engine executes the bytecode.\r\n\r\n## JavaScript Engine\r\n\r\nJavaScript Engine is a program that executes JavaScript code. It is responsible for interpreting and compiling the code, as well as optimizing its performance. The most popular JavaScript engines include V8, which is used in Google Chrome and Node.js, and SpiderMonkey, which is used in Mozilla Firefox.\r\n\r\n## ES6 vs Common JS\r\n\r\nES6, also known as ECMAScript 6, is a newer version of JavaScript that was released in 2015. It introduced several new features to the language, such as arrow functions, template literals, and classes, that make writing code in JavaScript much easier and more efficient. Common JS, on the other hand, is a module system for JavaScript that was developed for use in server-side environments.\r\n\r\nWhile ES6 is a newer and more modern version of JavaScript, Common JS is still widely used in server-side development. Node.js, a popular server-side JavaScript runtime environment, uses Common JS modules by default. However, many developers are shifting towards using ES6 modules for server-side development as well.\r\n\r\nRegardless of which version is used, JavaScript remains an incredibly versatile and powerful language. Its ability to be used for both client-side and server-side development, as well as its popularity within the developer community, make it an important language to learn for anyone interested in programming or web development.\r\n\r\n## Uses\r\n\r\nJavaScript can be used for a wide range of applications, including web development, server-side programming, and even desktop and mobile application development. It is also commonly used in game development, data visualization, and other areas where interactivity is important. With its versatility and popularity, JavaScript is a language that is well worth learning for anyone interested in programming or web development.\r\n\r\n## Resources\r\n\r\nHere are some stunning resources for learning js.\r\n\r\n### Books\r\n\r\n*   [https://eloquentjavascript.net/](https://eloquentjavascript.net/)\r\n*   [https://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742](https://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742)\r\n*   [https://kbpsystem777.github.io/You-Dont-Know-JS/](https://kbpsystem777.github.io/You-Dont-Know-JS/)\r\n\r\n### YouTube\r\n\r\n*   [https://www.youtube.com/watch?v=hdI2bqOjy3c](https://www.youtube.com/watch?v=hdI2bqOjy3c)\r\n*   [https://www.youtube.com/watch?v=jS4aFq5-91M](https://www.youtube.com/watch?v=jS4aFq5-91M)\r\n*   [https://www.youtube.com/watch?v=PoRJizFvM7s](https://www.youtube.com/watch?v=PoRJizFvM7s)\r\n\r\n### Udemy\r\n\r\n*   [https://www.udemy.com/course/the-complete-javascript-course/](https://www.udemy.com/course/the-complete-javascript-course/)\r\n*   [https://www.udemy.com/course/javascript-the-complete-guide-2020-beginner-advanced/](https://www.udemy.com/course/javascript-the-complete-guide-2020-beginner-advanced/)\r\n*   [https://www.udemy.com/course/javascript-basics-for-beginners/](https://www.udemy.com/course/javascript-basics-for-beginners/)\r\n\r\n### Websites\r\n\r\n*   [https://tc39.github.io/ecma262/](https://tc39.github.io/ecma262/)\r\n*   [https://developer.mozilla.org/en-US/docs/Web/JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript)\r\n*   [https://javascript.info/](https://javascript.info/)\r\n\r\n## Conclusion\r\n\r\nJavaScript is an incredibly powerful and versatile programming language. Its ability to create interactive web pages and its popularity within the developer community make it a valuable language to learn. Whether you are a beginner or an experienced developer, adding JavaScript to your skill set can help you to create more engaging and dynamic web applications."},{"id":"variables-in-js-var-let-const","metadata":{"permalink":"/blog/variables-in-js-var-let-const","editUrl":"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/1-variables-in-js-var-let-const.md","source":"@site/blog/javascript/1-variables-in-js-var-let-const.md","title":"Variables in JS: var, let, const","description":"JavaScript is a high-level programming language that is widely used for web development. One of the fundamental concepts in JavaScript is the use of variables. Variables are used to store data values that can be used throughout the code.","date":"2024-05-16T10:39:22.000Z","tags":[{"label":"javascript","permalink":"/blog/tags/javascript"}],"readingTime":6.345,"hasTruncateMarker":true,"authors":[{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"}],"frontMatter":{"slug":"variables-in-js-var-let-const","title":"Variables in JS: var, let, const","authors":{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"},"tags":["javascript"]},"unlisted":false,"prevItem":{"title":"Introduction to JavaScript","permalink":"/blog/introduction-to-js"},"nextItem":{"title":"Object Methods in JS","permalink":"/blog/object-methods-in-js"}},"content":"JavaScript is a high-level programming language that is widely used for web development. One of the fundamental concepts in JavaScript is the use of variables. Variables are used to store data values that can be used throughout the code.\r\n<!-- truncate -->\r\n\r\nThere are three different ways to declare variables in JavaScript: const, let, and var.\r\n\r\nvar\r\n===\r\n\r\nTo use `var` in JavaScript, you simply need to declare a variable using the keyword `var`, followed by the variable name and an optional assignment operator to set the initial value. For example:\r\n\r\n```js\r\nvar x = 5;  \r\nconsole.log(x); // 5  \r\nvar y;  \r\ny = 12;  \r\nconsole.log(y); // 12\r\n```\r\n\r\nIf you don’t initialize a variable declared with `var`, the initial value of variable is `undefined`.\r\n\r\n```js\r\nvar x;  \r\nconsole.log(x) // undefined\r\n```\r\n\r\nIn JavaScript, variables declared with the `var` keyword can be reinitialized, which means you can initialize a variable multiple times with different values.\r\n\r\n```js\r\nvar x = 5;  \r\nx = 18;  \r\nconsole.log(x) // 18\r\n```\r\n\r\nIn JavaScript, variables declared with the `var` keyword can also be redeclared within the same scope. This means you can declare the same variable multiple times with different values.\r\n\r\n```js\r\nvar x = 10;  \r\nconsole.log(x); // 10  \r\nvar x;  \r\nconsole.log(x); // undefined  \r\nvar x = 20;  \r\nconsole.log(x); // 20\r\n```\r\n\r\nScoping Rules\r\n-------------\r\n\r\nVariables declared with the `var` keyword have function-level scope. This means that if a variable is declared within a function, it is only accessible within that function.\r\n\r\n```js\r\nfunction myFunction() {  \r\n  var x = 10;  \r\n  console.log(x); // 10  \r\n}  \r\nmyFunction();  \r\nconsole.log(x); // ReferenceError: x is not defined\r\n```\r\n\r\nIf a variable is declared outside of a function, it is accessible throughout the entire program.\r\n\r\n```js\r\nvar x = 3;  \r\nfunction myFunction(){  \r\n\tx = 6 // global scoped   \r\n}  \r\nmyFunction();  \r\nconsole.log(x) // 6\r\n```\r\n\r\n```js\r\nvar x = 3;  \r\nfunction myFunction(){  \r\n\tvar x = 6 // local scoped to myFunction   \r\n}  \r\nmyFunction();  \r\nconsole.log(x) // 3\r\n```\r\n\r\nIt is important to note that `var` does not have block-level scope. This means that if a variable is declared within a block, such as an `if` statement or loop, it is still accessible outside of that block.\r\n\r\n```js\r\nif (true) {  \r\n  var x = 10;  \r\n}  \r\nconsole.log(x); // 10\r\n```\r\n\r\nHoisting\r\n--------\r\n\r\nOne important feature of `var` is hoisting, which means that variable declarations are moved to the top of their scope before the code is executed. This means that you can use a variable before it has been declared without getting an error.\r\n\r\n```js\r\nconsole.log(x); // undefined  \r\nvar x = 10;\r\n```\r\n\r\nThis code is equivalent to:\r\n\r\n```js\r\nvar x;  \r\nconsole.log(x); // undefined  \r\nx = 10;\r\n```\r\n\r\nFollowing code will also work fine because of the concept of hoisting in `var`\r\n\r\n```js\r\nx = 10;  \r\nvar x;  \r\nconsole.log(x); // 10\r\n```\r\n\r\nHowever, it is generally considered best practice to declare all variables at the beginning of their scope to avoid confusion and bugs in your code.\r\n\r\nlet\r\n===\r\n\r\n`let` is another way to declare variables in JavaScript.\r\n\r\n```js\r\nlet x = 5;  \r\nconsole.log(x); // 5  \r\nlet y;  \r\ny = 12;  \r\nconsole.log(y); // 12\r\n```\r\n\r\nYou can also use `let` to declare a variable without assigning a value to it. In this case, the variable will be initialized with the value `undefined`.\r\n\r\n```js\r\nlet x;  \r\nconsole.log(x); // undefined\r\n```\r\n\r\nUnlike `var`, `let` variables can be reassigned, but they cannot be redeclared within the same block.\r\n\r\n```js\r\nlet x = 12;  \r\nconsole.log(x); // 12  \r\nx = 14;  \r\nconsole.log(); // 14  \r\nlet x; // SyntaxError: Identifier 'x' has already been declared\r\n```\r\n\r\nScoping Rules\r\n-------------\r\n\r\n`let` variables have block-level scope. This means that if a variable is declared within a block, such as an `if` statement or loop, it is only accessible within that block. If a variable is declared outside of a block, it is accessible throughout the entire program.\r\n\r\n```js\r\nfunction myFunction(){  \r\n\tlet x = 9;  \r\n}  \r\nmyFunction();  \r\nconsole.log(x); // ReferenceError: x is not defined  \r\nif(true){  \r\n\tlet y = 2;  \r\n}  \r\nconsole.log(x); // ReferenceError: x is not defined\r\n```\r\n\r\nOn the other hand, if we declare `let x` outside of the function or any block, it is accessible throughout the entire program:\r\n\r\n```js\r\nlet x = 3;  \r\nfunction myFunction(){  \r\n\tx = 6 // initialized the outside variable x  \r\n}  \r\nmyFunction();  \r\nconsole.log(x) // 6  \r\nif(true){  \r\n\tx = 7;  \r\n}  \r\nconsole.log(x) // 7\r\n```\r\n\r\nWe can redeclare the variable in different block.\r\n\r\n```js\r\nlet x = 3;  \r\nfunction myFunction(){  \r\n\tlet x = 6 // local scoped to myFunction  \r\n}  \r\nmyFunction();  \r\nconsole.log(x) // 3\r\n```\r\n\r\n```js\r\nlet x = 3;  \r\nif (true) {  \r\n\tlet x = 6 // block scoped to if statement  \r\n\tconsole.log(x) // 6  \r\n}  \r\nconsole.log(x) // 3\r\n```\r\n\r\nHoisting\r\n--------\r\n\r\n`let` variables are not hoisted to the top of their scope. This means that if you try to use a `let` variable before it is declared, you will get a `ReferenceError`.\r\n\r\n```js\r\nconsole.log(x); // ReferenceError: x is not defined  \r\nlet x = 10;\r\n```\r\n\r\nconst\r\n=====\r\n\r\n`const` is used to declare a variable that cannot be reassigned, similar to a constant in other programming languages. However, it is important to note that the value of a `const` variable is not immutable. If the `const` variable is an object or an array, its properties or elements can still be modified.\r\n\r\n```js\r\nconst myObj = {name: \"John\", age: 30};  \r\nmyObj.age = 31;  \r\nconsole.log(myObj); // {name: \"John\", age: 31}\r\n```\r\n\r\nIt is also important to note that `const` variables have block-level scope, similar to `let` variables. This means that if a variable is declared within a block, such as an `if` statement or loop, it is only accessible within that block. If a variable is declared outside of a block, it is accessible throughout the entire program.\r\n\r\nLike `let`, `const` variables are not hoisted to the top of their scope. This means that if you try to use a `const` variable before it is declared, you will get a `ReferenceError`.\r\n\r\n```js\r\nconsole.log(x); // ReferenceError: x is not defined  \r\nconst x = 10;\r\n```\r\n\r\nIt is generally considered best practice to use `const` for variables that will not be reassigned, and `let` for variables that will be reassigned.\r\n\r\nVariable Naming Rules\r\n=====================\r\n\r\nIn JavaScript, variable names must follow certain rules to be valid. Here are the common rules for naming variables in JavaScript:\r\n\r\n1.  The variable name must start with a letter, underscore (_), or dollar sign ($). It cannot start with a number.\r\n2.  The variable name can contain letters, digits, underscores, or dollar signs. It is recommended to use only alphanumeric characters and underscores in variable names.\r\n3.  JavaScript is case sensitive, so `**myVariable**` and `**myvariable**` are two different variables.\r\n4.  Avoid using reserved words as variable names, such as `**if**`, `**else**`, `**while**`, etc.\r\n5.  Use descriptive names that reflect the purpose of the variable. This helps to make the code more readable and maintainable.\r\n6.  Do not use spaces in variable names. Use camelCase or underscores to separate words in the variable name.\r\n7.  Variable names should be concise and meaningful. A good variable name should accurately describe the data it holds or the purpose it serves.\r\n\r\nFollowing these rules and conventions helps to write clean, readable, and maintainable code in JavaScript.\r\n\r\nThis blog explains the three ways to declare variables in JavaScript: `const`, `let`, and `var`. It covers the syntax, scoping rules, and hoisting behavior of each type of variable, as well as best practices for using them. It also notes that `const` variables cannot be reassigned or redeclared, but their properties or elements can still be modified if they are objects or arrays."},{"id":"object-methods-in-js","metadata":{"permalink":"/blog/object-methods-in-js","editUrl":"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/10-object-methods-in-js.md","source":"@site/blog/javascript/10-object-methods-in-js.md","title":"Object Methods in JS","description":"JavaScript functions are a powerful tool that can help you build complex and dynamic web applications. Whether you’re building a simple website or a large-scale web application, functions are essential for adding interactivity and functionality to your code.","date":"2024-05-16T10:39:22.000Z","tags":[{"label":"javascript","permalink":"/blog/tags/javascript"}],"readingTime":5.39,"hasTruncateMarker":true,"authors":[{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"}],"frontMatter":{"slug":"object-methods-in-js","title":"Object Methods in JS","authors":{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"},"tags":["javascript"]},"unlisted":false,"prevItem":{"title":"Variables in JS: var, let, const","permalink":"/blog/variables-in-js-var-let-const"},"nextItem":{"title":"Regex Expressions in JS","permalink":"/blog/regex-expressions-in-js"}},"content":"JavaScript functions are a powerful tool that can help you build complex and dynamic web applications. Whether you’re building a simple website or a large-scale web application, functions are essential for adding interactivity and functionality to your code.\r\n<!-- truncate -->\r\n\r\nIn JavaScript, it’s possible to define functions as properties of an object. These functions are commonly referred to as methods.\r\n\r\n```js\r\n// Define a greetings object with a function to greet the user  \r\nconst greetings = {  \r\n  greetUser: function(name) {  \r\n    console.log(`Hello, ${name}! Welcome to our website.`);  \r\n  }  \r\n};  \r\n// Use the greetings object to greet the user  \r\ngreetings.greetUser(\"John\"); // \"Hello, John! Welcome to our website.\"\r\n```\r\n\r\nYou can achieve the similar functionality in this way:\r\n\r\n```js\r\n// Define a greetings object with a function to greet the user  \r\nconst greetings = {};  \r\ngreetings.greetUser = function(){  \r\n console.log(`Hello, ${name}! Welcome to our website.`);  \r\n}  \r\n// Use the greetings object to greet the user  \r\ngreetings.greetUser(\"John\"); // \"Hello, John! Welcome to our website.\"\r\n```\r\n\r\nArrow functions can also be used inside an object:\r\n\r\n```js\r\n// Define a greetings object with a function to greet the user  \r\nconst greetings = {  \r\n  greetUser: (name) => {  \r\n    console.log(`Hello, ${name}! Welcome to our website.`);  \r\n  }  \r\n};  \r\n// Use the greetings object to greet the user  \r\ngreetings.greetUser(\"John\"); // \"Hello, John! Welcome to our website.\"\r\n```\r\n\r\nThe `this` Keyword\r\n==================\r\n\r\nThe `this` keyword refers to the current object in JavaScript. It is often used inside object methods to refer to the object that the method belongs to.\r\n\r\nFor example, let’s say we have an object with a `name` property and a method called `greet`:\r\n\r\n```js\r\nconst person = {  \r\n  firstName: \"John\",  \r\n  lastName: \"Doe\",  \r\n  fullName: function() {  \r\n    return `${this.firstName} ${this.lastName}`;  \r\n  }  \r\n};  \r\nconsole.log(person.fullName()); // \"John Doe\"\r\n```\r\n\r\nWhen using arrow functions as methods inside objects, it’s important to be conscious of the value of the `**this**` keyword. Unlike regular functions, arrow functions do not have their own `**this**` context, but instead inherit the `**this**` value from their enclosing lexical scope. This can lead to unexpected behavior if you're not careful.\r\n\r\n```js\r\nconst person = {  \r\n  firstName: \"John\",  \r\n  lastName: \"Doe\",  \r\n  fullName: () => {  \r\n    return `${this.firstName} ${this.lastName}`;  \r\n  }  \r\n};  \r\nconsole.log(person.fullName()); // \"undefined undefined\"\r\n```\r\n\r\nHere’s an example of how you can use an arrow function inside an object method:\r\n\r\n```js\r\nconst calculator = {  \r\n  operand1: 0,  \r\n  operand2: 0,  \r\n  add: function() {  \r\n    const sum = () => {  \r\n\t\t\t/*  \r\n\t\t\t* As arrow functions inherit this value from their enclosing lexical scope,  \r\n\t\t\t* now it is inheriting from add function context  \r\n\t\t\t*/  \r\n      return this.operand1 + this.operand2;  \r\n    }  \r\n    console.log(`Sum: ${sum()}`);  \r\n  }  \r\n};  \r\ncalculator.operand1 = 10;  \r\ncalculator.operand2 = 20;  \r\ncalculator.add(); // \"Sum: 30\"\r\n```\r\n\r\nThe `new` Keyword\r\n=================\r\n\r\nIn JavaScript, the `**new**` keyword is used to create new instances of a constructor function. A constructor function is a special type of function that is used to create and initialize objects with the same properties and methods.\r\n\r\nWhen the `**new**` keyword is used with a constructor function, a new object is created with its own set of properties and methods. The `**this**` keyword inside the constructor function refers to the new object being created, and can be used to set the initial values of its properties.\r\n\r\nHere’s an example of using the `**new**` keyword to create a new instance of a constructor function:\r\n\r\n```js\r\nfunction Person(firstName, lastName) {  \r\n  this.firstName = firstName;  \r\n  this.lastName = lastName;  \r\n}  \r\nconst person1 = new Person('John', 'Doe');  \r\nconst person2 = new Person('Jane', 'Doe');  \r\nconsole.log(person1); // Person { firstName: 'John', lastName: 'Doe' }  \r\nconsole.log(person2); // Person { firstName: 'Jane', lastName: 'Doe' }\r\n```\r\n\r\nThe `**new**` keyword is used to create two instances of `**Person**`: `**person1**` and `**person2**`. Each instance has its own set of properties `**firstName**` and `**lastName**` with different values.\r\n\r\nNote that the `**new**` keyword is not necessary when creating objects using object literals `**{}**` or when using classes in modern JavaScript. However, it is still commonly used when working with constructor functions or legacy code.\r\n\r\nYou can also define methods in an object instance with this way:\r\n\r\n```js\r\nfunction Person(name, age) {  \r\n  this.name = name;  \r\n  this.age = age;  \r\n}  \r\nPerson.prototype.greet = function() {  \r\n  console.log('Hello, my name is ' + this.name + ' and I am ' + this.age + ' years old.');  \r\n};  \r\nconst person1 = new Person('John', 30);  \r\nperson1.greet(); // \"Hello, my name is John and I am 30 years old.\"\r\n```\r\n\r\nInheritance can achieve in this way:\r\n\r\n```js\r\nfunction Animal(name) {  \r\n  this.name = name;  \r\n}  \r\nAnimal.prototype.speak = function() {  \r\n  console.log(`${this.name} makes a noise.`);  \r\n}  \r\nfunction Dog(name) {  \r\n  Animal.call(this, name);  \r\n}  \r\nDog.prototype = Object.create(Animal.prototype);  \r\nDog.prototype.constructor = Dog;  \r\nDog.prototype.speak = function() {  \r\n  console.log(`${this.name} barks.`);  \r\n}  \r\nlet dog = new Dog('Rex');  \r\ndog.speak(); // \"Rex barks.\"\r\n```\r\n\r\nGetter and Setter\r\n=================\r\n\r\nEncapsulation is a technique used to control access to object properties and methods. One way to achieve encapsulation in JavaScript is to use a naming **convention** where properties that are intended to be protected are prefixed with an underscore (`**_**`).\r\n\r\nBy convention, properties and methods that start with an underscore are meant to be accessed only within the object, and not from outside the object. This means that developers can create private properties and methods that are hidden from the outside world, while still allowing public properties and methods to be accessed and used as intended.\r\n\r\n```js\r\nconst person = {  \r\n  _name: 'John',  \r\n};  \r\n// Accessing the private _name property directly from outside the object  \r\nconsole.log(person._name); // 'Jane'  \r\n// Attempting to modify the private _name property directly from outside the object  \r\nperson._name = 'Bob';  \r\nconsole.log(person._name); // 'Bob'\r\n```\r\n\r\nGetter and setter methods are a way to control access to object properties. They allow you to define custom behavior when getting or setting a property’s value. To define a getter or setter method, use the `get` or `set` keyword followed by the name of the property you want to define the behavior for. For example:\r\n\r\n```js\r\nconst person = {  \r\n  _firstName: \"John\",  \r\n  _lastName: \"Doe\",  \r\n  get fullName() {  \r\n    return `${this._firstName} ${this._lastName}`;  \r\n  },  \r\n  set fullName(name) {  \r\n    const parts = name.split(\" \");  \r\n    this._firstName = parts[0];  \r\n    this._lastName = parts[1];  \r\n  }  \r\n};  \r\nconsole.log(person.fullName); // \"John Doe\"  \r\nperson.fullName = \"Jane Smith\";  \r\nconsole.log(person.fullName); // \"Jane Smith\"\r\n```\r\n\r\n**Note:** In more recent versions of JavaScript # is introduced for strictly enforcing private fields but it has limited support.\r\n\r\nIn summary, defining functions inside objects can be useful for encapsulating related functionality and keeping your code organized. Additionally, it allows you to access other properties and methods of the same object, which can be helpful for building more complex functionality."},{"id":"regex-expressions-in-js","metadata":{"permalink":"/blog/regex-expressions-in-js","editUrl":"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/11-regex-expressions-in-js.md","source":"@site/blog/javascript/11-regex-expressions-in-js.md","title":"Regex Expressions in JS","description":"JavaScript is a programming language that supports regular expressions (regex). A regular expression is a sequence of characters that specifies a search pattern. With regex, we can search and manipulate text data in a more efficient and flexible way. In this document, we will explore how to use regular expressions in JavaScript.","date":"2024-05-16T10:39:22.000Z","tags":[{"label":"javascript","permalink":"/blog/tags/javascript"}],"readingTime":5.01,"hasTruncateMarker":true,"authors":[{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"}],"frontMatter":{"slug":"regex-expressions-in-js","title":"Regex Expressions in JS","authors":{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"},"tags":["javascript"]},"unlisted":false,"prevItem":{"title":"Object Methods in JS","permalink":"/blog/object-methods-in-js"},"nextItem":{"title":"Protype in JS","permalink":"/blog/protype-in-js"}},"content":"JavaScript is a programming language that supports regular expressions (regex). A regular expression is a sequence of characters that specifies a search pattern. With regex, we can search and manipulate text data in a more efficient and flexible way. In this document, we will explore how to use regular expressions in JavaScript.\r\n<!-- truncate -->\r\n\r\n**Flags:**\r\n\r\n*   `**g**`: Global match. This flag indicates that the regular expression should match all occurrences in the input string, rather than just the first one.\r\n*   `**i**`: Case-insensitive match. This flag indicates that the regular expression should match regardless of the casing of the input string.\r\n*   `**m**`: Multiline match. This flag indicates that the regular expression should match across multiple lines of the input string.\r\n\r\n**Patterns:**\r\n\r\n1.  Matching any character: `**.**`\r\n2.  Matching any digit: `**\\\\d**`\r\n3.  Matching any non-digit: `**\\\\D**`\r\n4.  Matching any whitespace character: `**\\\\s**`\r\n5.  Matching any non-whitespace character: `**\\\\S**`\r\n6.  Matching any word character: `**\\\\w**`\r\n7.  Matching any non-word character: `**\\\\W**`\r\n8.  Matching a specific number of characters: `**{n}**`\r\n9.  Matching zero or more occurrences: **``**\r\n10.  Matching one or more occurrences: `**+**`\r\n11.  Matching zero or one occurrence: `**?**`\r\n12.  Matching the start of a string: `**^**`\r\n13.  Matching the end of a string: `**$**`\r\n14.  Matching a range of characters: `**[abc]**`\r\n15.  Matching any character not in a range: `**[^abc]**`\r\n16.  Matching any character in a range of characters: `**[a-z]**`\r\n17.  Matching any character not in a range of characters: `**[^a-z]**`\r\n18.  Matching any character except newline: `**[\\\\s\\\\S]**`\r\n19.  Matching a specific character: `**\\**`\r\n20.  Matching a specific word boundary: `**\\\\b**`\r\n21.  Matching a negative word boundary: `**\\\\B**`\r\n22.  Capturing a group of characters: `**( )**`\r\n23.  Non-capturing a group of characters: `**(?: )**`\r\n24.  Matching one of several patterns: `**(pattern1|pattern2|pattern3)**`\r\n25.  Using a backreference to match a previous captured group: `**\\\\n**`\r\n26.  Matching any number of characters lazily: `**?**`\r\n27.  Matching one or more characters lazily: `**+?**`\r\n28.  Matching a specific number of characters lazily: `**{n}?**`\r\n29.  Using lookahead to match a pattern only if it’s followed by another pattern: `**(?= )**`\r\n30.  Using lookbehind to match a pattern only if it’s preceded by another pattern: `**(?<= )**`\r\n\r\n```js\r\n// Matches all occurrences of the word \"dog\"  \r\nconst regex = /dog/g;  \r\n// Matches the word \"hello\" regardless of case  \r\nconst regex = /hello/i;  \r\n// Matches the pattern \"cat\" at the beginning of a string  \r\nconst regex = /^cat/;  \r\n// Matches the pattern \"bat\" at the end of a string  \r\nconst regex = /bat$/;  \r\n// Matches any vowel character  \r\nconst regex = /[aeiou]/;  \r\n// Matches any non-vowel character  \r\nconst regex = /[^aeiou]/;  \r\n// Matches either \"cat\" or \"dog\"  \r\nconst regex = /cat|dog/;  \r\n// Groups together \"hello\" and \"world\" and captures the result  \r\nconst regex = /(hello) (world)/;\r\n```\r\n\r\n**Most Used Regex Patterns**\r\n\r\n1.  Email addresses:\r\n\r\n*   `**\\\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Z|a-z]{2,}\\\\b**` - this matches most standard email addresses and ensures that the domain name ends with at least two letters.\r\n\r\n2\\. Phone numbers:\r\n\r\n*   `**\\\\b\\\\d{3}[-.]?\\\\d{3}[-.]?\\\\d{4}\\\\b**` - this matches most US phone numbers, with or without dashes or periods between groups of digits.\r\n\r\n3\\. URLs:\r\n\r\n*   `**(http(s)?://)?([\\\\w-]+\\\\.)+[\\\\w-]+(/[\\\\w- ;,./?%&=]*)?**` - this matches most standard URLs, including those with or without the `**http://**` or `**https://**` prefixes, and with or without query parameters.\r\n\r\n4\\. Postal codes:\r\n\r\n*   `**[A-Z]\\\\d[A-Z] ?\\\\d[A-Z]\\\\d**` - this matches most Canadian postal codes, which have the format A1A 1A1, with the first three characters being a letter, followed by a digit, followed by another letter, and then a space, and then a digit, followed by another letter, and then a digit.\r\n\r\n5\\. IP addresses:\r\n\r\n*   `**\\\\b\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}\\\\b**` - this matches most standard IP addresses, with each group of digits separated by periods.\r\n\r\n6\\. Dates:\r\n\r\n*   `**\\\\b\\\\d{1,2}[\\\\/\\\\-]\\\\d{1,2}[\\\\/\\\\-]\\\\d{4}\\\\b**` - this matches most standard date formats, with the month and day separated by either a slash or a dash, and the year consisting of four digits.\r\n\r\n7\\. Credit card numbers:\r\n\r\n*   `**\\\\b\\\\d{4}([ \\\\-]?\\\\d{4}){3}\\\\b**` - this matches most standard credit card numbers, with groups of four digits separated by either spaces or dashes.\r\n\r\n8\\. Social Security numbers:\r\n\r\n*   `**\\\\b\\\\d{3}[ \\\\-]?\\\\d{2}[ \\\\-]?\\\\d{4}\\\\b**` - this matches most standard SSN formats, with groups of three, two, and four digits separated by either spaces or dashes.\r\n\r\n9\\. File paths:\r\n\r\n*   `**^[A-Za-z]:[\\\\\\\\/].***` - this matches most standard file paths on Windows systems, with the drive letter followed by a colon, and then the rest of the path separated by either backslashes or forward slashes.\r\n\r\nCreating a Regex Object\r\n=======================\r\n\r\nIn JavaScript, we can create a regex object using the `RegExp` constructor or by using a regex literal. Here is an example:\r\n\r\n```js\r\n// Using RegExp constructor  \r\nlet regex1 = new RegExp('hello');  \r\nconsole.log(regex1.test('hello world')); // true  \r\n// Using regex literal  \r\nlet regex2 = /hello/;  \r\nconsole.log(regex2.test('world hello')); // true\r\n```\r\n\r\nMatching a Pattern\r\n==================\r\n\r\nTo match a pattern in a string, we can use the `match` method. This method returns an array of matches or `null` if no matches are found. Here is an example:\r\n\r\n```js\r\nlet str = 'The quick brown fox jumps over the lazy dog';  \r\nlet regex = /the/gi;  \r\nlet matches = str.match(regex);  \r\nconsole.log(matches); // [\"The\", \"the\"]\r\n```\r\n\r\nIn this example, we used the `g` and `i` flags to match all occurrences of the word \"the\" in a case-insensitive way.\r\n\r\nReplacing a Pattern\r\n===================\r\n\r\nTo replace a pattern in a string, we can use the `replace` method. This method returns a new string with the replaced value. Here is an example:\r\n\r\n```js\r\nlet str = 'JavaScript is a popular programming language';  \r\nlet regex = /JavaScript/;  \r\nlet newStr = str.replace(regex, 'JS');  \r\nconsole.log(newStr); // \"JS is a popular programming language\"\r\n```\r\n\r\nIn this example, we used the `replace` method to replace the word \"JavaScript\" with \"JS\" in the string.\r\n\r\nConclusion\r\n==========\r\n\r\nRegular expressions are a powerful tool in JavaScript for searching and manipulating text data. We can create regex objects using the `RegExp` constructor or regex literals. We can match a pattern using the `match` method and replace a pattern using the `replace` method. With regular expressions, we can write more efficient and flexible code."},{"id":"protype-in-js","metadata":{"permalink":"/blog/protype-in-js","editUrl":"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/12-protype-in-js.md","source":"@site/blog/javascript/12-protype-in-js.md","title":"Protype in JS","description":"JavaScript is an object-oriented programming (OOP) language that uses prototypes instead of classes for creating objects. Prototypes are a fundamental concept in JavaScript and understanding them is essential in creating efficient and effective code.","date":"2024-05-16T10:39:22.000Z","tags":[{"label":"javascript","permalink":"/blog/tags/javascript"}],"readingTime":4.325,"hasTruncateMarker":true,"authors":[{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"}],"frontMatter":{"slug":"protype-in-js","title":"Protype in JS","authors":{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"},"tags":["javascript"]},"unlisted":false,"prevItem":{"title":"Regex Expressions in JS","permalink":"/blog/regex-expressions-in-js"},"nextItem":{"title":"Function Binding in JS","permalink":"/blog/function-binding-in-js"}},"content":"JavaScript is an object-oriented programming (OOP) language that uses prototypes instead of classes for creating objects. Prototypes are a fundamental concept in JavaScript and understanding them is essential in creating efficient and effective code.\r\n<!-- truncate -->\r\n\r\nWhat is a Prototype?\r\n====================\r\n\r\nA prototype is an object that is associated with every constructor function in JavaScript that acts as a blueprint for creating new objects. When a new object is created using a constructor function, the prototype of the constructor function is set as the prototype of the new object. In other words, the prototype is like a template for the object, defining its properties and methods.\r\n\r\nPrototype Chain\r\n===============\r\n\r\nThe prototype chain is a series of links between objects. When a property is accessed on an object, JavaScript first looks for the property on the object itself. If the property is not found, JavaScript looks at the object’s prototype. If the property is not found on the prototype, JavaScript looks at the prototype’s prototype, and so on, until the property is found or until the end of the prototype chain is reached (which is the Object.prototype).\r\n\r\nThis concept of the prototype chain is essential to JavaScript programming, and understanding how it works is crucial. It allows developers to create complex and powerful code by building objects that are linked together in a chain of prototypes.\r\n\r\nCreating Prototypes\r\n===================\r\n\r\nPrototypes can be created in several ways in JavaScript. One way to create a prototype is to use the constructor function syntax:\r\n\r\n```js\r\nfunction Car(make, model, year) {  \r\n    this.make = make;  \r\n    this.model = model;  \r\n    this.year = year;  \r\n}  \r\nCar.prototype.getInfo = function() {  \r\n    return this.make + ' ' + this.model + ' (' + this.year + ')';  \r\n};\r\n```\r\n\r\nYou can initiate different instances of Car.\r\n\r\n```js\r\nconst car1 = new Car('Abc', 'Xyz', '2000');  \r\nconst car2 = new Car('Def', 'Uvw', '2020');  \r\ncar1.getInfo(); // Abc Xyz 2000\r\n```\r\n\r\nUsing Prototypes\r\n================\r\n\r\nAnother way is to use the object literal syntax. For example, let’s say we want to create a prototype object for a car:\r\n\r\n```js\r\nlet carPrototype = {  \r\n    make: 'Honda',  \r\n    model: 'Civic',  \r\n    year: 2021,  \r\n    getInfo: function() {  \r\n        return this.make + ' ' + this.model + ' (' + this.year + ')';  \r\n    }  \r\n};\r\n```\r\n\r\nOnce a prototype is created, it can be used to create new objects. To create a new object using a prototype, you can use the `Object.create()` method:\r\n\r\n```js\r\nlet myCar = Object.create(carPrototype);\r\n```\r\n\r\nIn this example, `myCar` is a new object that has `carPrototype` as its prototype. We can then access the properties and methods of `carPrototype` through `myCar`:\r\n\r\n```js\r\nconsole.log(myCar.make); // 'Honda'  \r\nconsole.log(myCar.model); // 'Civic'  \r\nconsole.log(myCar.year); // 2021  \r\nconsole.log(myCar.getInfo()); // 'Honda Civic (2021)'\r\n```\r\n\r\nModifying Prototypes\r\n====================\r\n\r\nPrototypes can be modified at runtime, which means that changes made to a prototype will affect all objects that are created using that prototype. For example, you can add a new property to a prototype like this:\r\n\r\n```js\r\ncarPrototype.color = 'red';\r\n```\r\n\r\nAll objects that are created using `carPrototype` will now have a `color` property with a value of `'red'`.\r\n\r\nRelated Methods\r\n===============\r\n\r\n1.  `Object.getPrototypeOf`\r\n\r\n```js\r\nconst person = {  \r\n  firstName: 'John',  \r\n  lastName: 'Doe',  \r\n  getFullName() {  \r\n    return `${this.firstName} ${this.lastName}`;  \r\n  }  \r\n};  \r\nconst john = Object.create(person);  \r\nconsole.log(Object.getPrototypeOf(john) === person); // true\r\n```\r\n\r\n1.  `Object.setPrototypeOf`\r\n\r\n```js\r\nconst person = {  \r\n  firstName: 'John',  \r\n  lastName: 'Doe',  \r\n  getFullName() {  \r\n    return `${this.firstName} ${this.lastName}`;  \r\n  }  \r\n};  \r\nconst john = {};  \r\nObject.setPrototypeOf(john, person);  \r\nconsole.log(john.getFullName()); // John Doe\r\n```\r\n\r\n1.  `Object.prototype.isPrototypeOf()`\r\n\r\n```js\r\nconst person = {  \r\n  firstName: 'John',  \r\n  lastName: 'Doe',  \r\n  getFullName() {  \r\n    return `${this.firstName} ${this.lastName}`;  \r\n  }  \r\n};  \r\nconst john = Object.create(person);  \r\nconsole.log(person.isPrototypeOf(john)); // true\r\n```\r\n\r\n1.  `Object.prototype.hasOwnProperty()`\r\n\r\n```js\r\nconst person = {  \r\n  firstName: 'John',  \r\n  lastName: 'Doe',  \r\n  getFullName() {  \r\n    return `${this.firstName} ${this.lastName}`;  \r\n  }  \r\n};  \r\nconst john = Object.create(person);  \r\njohn.age = 25;  \r\nconsole.log(john.hasOwnProperty('age')); // true  \r\nconsole.log(john.hasOwnProperty('getFullName')); // false\r\n```\r\n\r\n1.  `Object.prototype.toString()`\r\n\r\n```js\r\nconst person = {  \r\n  firstName: 'John',  \r\n  lastName: 'Doe',  \r\n  getFullName() {  \r\n    return `${this.firstName} ${this.lastName}`;  \r\n  }  \r\n};  \r\nconsole.log(person.toString()); // [object Object]\r\n```\r\n\r\n1.  `Object.getOwnPropertyNames()`\r\n\r\n```js\r\nconst person = {  \r\n  firstName: 'John',  \r\n  lastName: 'Doe',  \r\n  getFullName() {  \r\n    return `${this.firstName} ${this.lastName}`;  \r\n  }  \r\n};  \r\nconst john = Object.create(person);  \r\njohn.age = 25;  \r\nconsole.log(Object.getOwnPropertyNames(john)); // [\"age\"]\r\n```\r\n\r\n1.  `Object.defineProperties()`\r\n\r\n```js\r\nconst person = {};  \r\nObject.defineProperties(person, {  \r\n  firstName: {  \r\n    value: 'John',  \r\n    writable: true,  \r\n    enumerable: true,  \r\n    configurable: true  \r\n  },  \r\n  lastName: {  \r\n    value: 'Doe',  \r\n    writable: true,  \r\n    enumerable: true,  \r\n    configurable: true  \r\n  },  \r\n  fullName: {  \r\n    get() {  \r\n      return `${this.firstName} ${this.lastName}`;  \r\n    },  \r\n    enumerable: true,  \r\n    configurable: true  \r\n  }  \r\n});  \r\nconsole.log(person.fullName); // \"John Doe\"\r\n```\r\n\r\n```js\r\nconst person = {  \r\n  firstName: 'John',  \r\n  lastName: 'Doe'  \r\n};  \r\nconsole.log(person.propertyIsEnumerable('firstName')); // true  \r\nconsole.log(person.propertyIsEnumerable('toString')); // false\r\n```\r\n\r\n1.  `Object.prototype.propertyIsEnumerable()`\r\n2.  `Object.getOwnPropertyDescriptors()`\r\n\r\n```js\r\nconst person = {  \r\n  firstName: 'John',  \r\n  lastName: 'Doe'  \r\n};  \r\nObject.defineProperty(person, 'age', {  \r\n  value: 25,  \r\n  writable: true,  \r\n  enumerable: true,  \r\n  configurable: true  \r\n});  \r\nconst descriptors = Object.getOwnPropertyDescriptors(person);  \r\nconsole.log(descriptors.firstName); // { value: 'John', writable: true, enumerable: true, configurable: true }  \r\nconsole.log(descriptors.age); // { value: 25, writable: true, enumerable: true, configurable: true }\r\n```\r\n\r\nPrototypes are a fundamental concept in JavaScript and are essential in creating efficient and effective code. By understanding the prototype chain and how to create and use prototypes, you can take your JavaScript programming skills to the next level. With prototypes, you can create powerful objects that are linked together in a chain, providing a flexible and scalable way to build complex applications."},{"id":"function-binding-in-js","metadata":{"permalink":"/blog/function-binding-in-js","editUrl":"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/13-function-binding-in-js.md","source":"@site/blog/javascript/13-function-binding-in-js.md","title":"Function Binding in JS","description":"JavaScript is a versatile language that allows developers to create complex applications with ease. One of the language’s most powerful features is its ability to manipulate the behavior of functions through binding.","date":"2024-05-16T10:39:22.000Z","tags":[{"label":"javascript","permalink":"/blog/tags/javascript"}],"readingTime":6.77,"hasTruncateMarker":true,"authors":[{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"}],"frontMatter":{"slug":"function-binding-in-js","title":"Function Binding in JS","authors":{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"},"tags":["javascript"]},"unlisted":false,"prevItem":{"title":"Protype in JS","permalink":"/blog/protype-in-js"},"nextItem":{"title":"Class in JS","permalink":"/blog/class-in-js"}},"content":"JavaScript is a versatile language that allows developers to create complex applications with ease. One of the language’s most powerful features is its ability to manipulate the behavior of functions through binding.\r\n<!-- truncate -->\r\n\r\nUnderstanding Binding\r\n=====================\r\n\r\nIn JavaScript, binding refers to the process of assigning a specific context or value to the ‘this’ keyword inside a function. By default, the ‘this’ keyword refers to the global object, but when a function is bound to a specific context or value, ‘this’ will refer to that context instead.\r\n\r\nFor example, consider the following code snippet:\r\n\r\n```js\r\nconst person = {  \r\n  name: 'John',  \r\n  greet: function() {  \r\n    console.log(`Hello, my name is ${this.name}`);  \r\n  }  \r\n}  \r\nperson.greet(); // Output: Hello, my name is John\r\n```\r\n\r\nIn this example, the ‘this’ keyword inside the ‘greet’ method refers to the ‘person’ object. We can also bind the ‘greet’ method to a different context by using the ‘bind’ method, like so:\r\n\r\n```js\r\nconst anotherPerson = {  \r\n  name: 'Sarah'  \r\n}  \r\nconst greetAnotherPerson = person.greet.bind(anotherPerson);  \r\ngreetAnotherPerson(); // Output: Hello, my name is Sarah\r\n```\r\n\r\nHere, we have bound the ‘greet’ method to the ‘anotherPerson’ object using the ‘bind’ method. This means that when we call ‘greetAnotherPerson’, the ‘this’ keyword inside the ‘greet’ method will refer to the ‘anotherPerson’ object instead of the ‘person’ object.\r\n\r\nThe Benefits of Binding\r\n=======================\r\n\r\nBinding is a powerful tool in JavaScript because it allows developers to control the behavior of functions in a more flexible way. By binding a function to a specific context, we can ensure that it behaves consistently regardless of where it is called from. This is especially useful when working with objects that have methods, as it allows us to easily reuse those methods in different contexts.\r\n\r\nAnother benefit of binding is that it allows us to create new functions that inherit the behavior of existing functions. This is known as function currying and is a common technique used in functional programming. By binding some of the arguments of a function to specific values, we can create a new function that takes fewer arguments and behaves differently than the original function.\r\n\r\n`call` method\r\n=============\r\n\r\nThe `**call()**` method is a built-in JavaScript function that allows you to call a function with a specified `**this**` value and arguments provided individually, instead of as an array (as with the `**apply()**` method).\r\n\r\nThe main purpose of the `**call()**` method is to execute a function with a specified `**this**` value, so you can control the value of `**this**` inside a function when it is called. By default, the `**this**` keyword inside a function refers to the global `**window**` object in a web browser, or to the global `**global**` object in Node.js.\r\n\r\nHowever, by using the `**call()**` method, you can specify a different `**this**` value, such as an object that contains the properties and methods you want to use inside the function. This allows you to reuse a function with different objects and ensure that the function is executed in the correct context.\r\n\r\nIn addition to specifying a `**this**` value, the `**call()**` method also allows you to pass in arguments to the function individually, instead of as an array (as with the `**apply()**` method). This can be useful if you have a function that expects multiple arguments and you want to specify them individually, rather than as an array.\r\n\r\n```js\r\nconst person = {  \r\n  firstName: 'John',  \r\n  lastName: 'Doe',  \r\n  getFullName: function() {  \r\n    return this.firstName + ' ' + this.lastName;  \r\n  }  \r\n}  \r\nconst person2 = {  \r\n  firstName: 'Jane',  \r\n  lastName: 'Doe'  \r\n}  \r\nconst fullName = person.getFullName.call(person2);  \r\nconsole.log(fullName); // 'Jane Doe'\r\n```\r\n\r\n```js\r\nfunction greet(greeting, punctuation) {  \r\n  console.log(`${greeting}, ${this.name}${punctuation}`);  \r\n}  \r\nconst person = { name: 'John' };  \r\nconst args = ['Hello', '!'];  \r\n// Call greet with person as the this value and args as the arguments  \r\ngreet.apply(person, args);\r\n```\r\n\r\n`apply` method\r\n==============\r\n\r\nThe `**apply()**` method in JavaScript is used to call a function with a specified `**this**` value and arguments provided as an array. The main purpose of this method is to execute a function in a specific context or scope, which can be useful in scenarios where you want to reuse a function with different objects and ensure that the function is executed in the correct context.\r\n\r\nOne of the primary use cases of the `**apply()**` method is to set the value of the `**this**` keyword inside a function to a specific object. By passing in an object as the first argument to the `**apply()**` method, you can set the `**this**` keyword to that object when the function is called. This is especially useful in cases where the function is designed to work with a specific object's properties and methods.\r\n\r\nAnother advantage of the `**apply()**` method is that it allows you to pass in arguments to a function as an array. This can be useful if you have a function that expects multiple arguments, and you want to pass them in as an array rather than individually. The `**apply()**` method can also be used to call a function with a variable number of arguments since you can pass in the arguments as an array, and the function can then use the `**length**` property of the array to determine how many arguments were passed in.\r\n\r\n```js\r\nfunction greet(greeting, punctuation) {  \r\n  console.log(`${greeting}, ${this.name}${punctuation}`);  \r\n}  \r\nconst person = { name: 'John' };  \r\nconst args = ['Hello', '!'];  \r\n// Call greet with person as the this value and args as the arguments  \r\ngreet.apply(person, args);\r\n```\r\n\r\nThe `call` method is also use to call constructor of parent\r\n\r\n```js\r\nfunction Animal(name) {  \r\n  this.name = name;  \r\n}  \r\nfunction Cat(name, color) {  \r\n  Animal.call(this, name);  \r\n  this.color = color;  \r\n}  \r\nconst myCat = new Cat('Fluffy', 'orange');  \r\nconsole.log(myCat.name); // Fluffy  \r\nconsole.log(myCat.color); // orange\r\n```\r\n\r\n`bind` method\r\n=============\r\n\r\nIn JavaScript, the `**bind()**` method is used to create a new function that has a specific `**this**` value and, optionally, arguments that are pre-set. When the new function is called, the `**this**` keyword inside the function body will be bound to the value passed as the first argument to the `**bind()**` method.\r\n\r\nThe `**bind()**` method is commonly used in scenarios where a function needs to be passed as a callback or event handler, but the `**this**` value needs to be a specific object, and not the default `**this**` value that is determined by the context of the function call. By using `**bind()**`, you can ensure that the `**this**` value inside the function is always what you expect it to be.\r\n\r\n```js\r\nconst person = {  \r\n  name: 'John',  \r\n  greet: function() {  \r\n    console.log(`Hello, my name is ${this.name}.`);  \r\n  }  \r\n};  \r\nconst person1 = {  \r\n name: 'Jane',  \r\n}  \r\nconst boundGreet = person.greet.bind(person1);  \r\n// Call the boundGreet function  \r\nboundGreet();\r\n```\r\n\r\nDifference\r\n==========\r\n\r\nHere is difference between these three methods:\r\n\r\n1.  `**call**`: The `**call**` method invokes a function with a specified `**this**` value and arguments provided as a comma-separated list. The first argument of `**call**` is the `**this**` value, followed by any arguments the function requires.\r\n2.  `**apply**`: The `**apply**` method is similar to `**call**`, but the arguments are provided as an array. The first argument of `**apply**` is the `**this**` value, followed by an array of arguments.\r\n3.  `**bind**`: The `**bind**` method creates a new function with the same body as the original function, but with a specified `**this**` value. It returns a new function that can be called later with the provided `**this**` value and arguments.\r\n\r\n```js\r\nfunction greet(name) {  \r\n  console.log(`Hello, ${name}! My name is ${this.name}.`);  \r\n}  \r\nconst person1 = { name: 'John' };  \r\nconst person2 = { name: 'Alice' };  \r\ngreet.call(person1, 'Alice'); // Hello, Alice! My name is John.  \r\ngreet.apply(person2, ['Bob']); // Hello, Bob! My name is Alice.  \r\nconst boundGreet = greet.bind(person1);  \r\nboundGreet('Alice'); // Hello, Alice! My name is John.\r\n```\r\n\r\nBinding is a powerful technique in JavaScript that allows us to control the behavior of functions in a flexible way. By binding functions to specific contexts, we can ensure that they behave consistently regardless of where they are called from. We can also use binding to create new functions that inherit the behavior of existing functions. By mastering the basics of binding, developers can unlock the full potential of JavaScript and create applications that are both powerful and flexible."},{"id":"class-in-js","metadata":{"permalink":"/blog/class-in-js","editUrl":"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/14-class-in-js.md","source":"@site/blog/javascript/14-class-in-js.md","title":"Class in JS","description":"Object-Oriented Programming (OOP) is a popular paradigm used in modern programming languages to organize code and data into reusable and modular components. JavaScript, although originally designed as a scripting language, has gained significant support for OOP. In this blog, we’ll discuss the principles of OOP in JavaScript and how to use them effectively.","date":"2024-05-16T10:39:22.000Z","tags":[{"label":"javascript","permalink":"/blog/tags/javascript"}],"readingTime":7.005,"hasTruncateMarker":true,"authors":[{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"}],"frontMatter":{"slug":"class-in-js","title":"Class in JS","authors":{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"},"tags":["javascript"]},"unlisted":false,"prevItem":{"title":"Function Binding in JS","permalink":"/blog/function-binding-in-js"},"nextItem":{"title":"Advanced Datatypes in JS","permalink":"/blog/advanced-datatypes-in-js"}},"content":"Object-Oriented Programming (OOP) is a popular paradigm used in modern programming languages to organize code and data into reusable and modular components. JavaScript, although originally designed as a scripting language, has gained significant support for OOP. In this blog, we’ll discuss the principles of OOP in JavaScript and how to use them effectively.\r\n<!-- truncate -->\r\n\r\nDefining a Class\r\n================\r\n\r\nThe syntax for defining a class in JavaScript is as follows:\r\n\r\n```js\r\nclass MyClass {  \r\n  constructor(arg1, arg2) {  \r\n    this.property1 = arg1;  \r\n    this.property2 = arg2;  \r\n  }  \r\nmethod1() {  \r\n    // Method code here  \r\n  }  \r\n  method2() {  \r\n    // Method code here  \r\n  }  \r\n}\r\n```\r\n\r\nOnce you have defined a class, you can create an instance of the class using the `**new**` keyword:\r\n\r\n```js\r\nconst myInstance = new MyClass('value1', 'value2');\r\n```\r\n\r\nProperties\r\n==========\r\n\r\nIn JavaScript classes, properties are defined in the constructor method and are assigned to the `**this**` keyword, which refers to the instance of the class. Here's an example of defining properties inside a class:\r\n\r\n```js\r\nclass Person {  \r\n  constructor(name, age) {  \r\n    this.name = name;  \r\n    this.age = age;  \r\n  }  \r\nget occupation() {  \r\n    return 'Software Developer';  \r\n  }  \r\n}  \r\nconst john = new Person('John', 30);  \r\nconsole.log(john.occupation); // 'Software Developer'\r\n```\r\n\r\nMethods\r\n=======\r\n\r\nIn JavaScript classes, methods are functions that are defined inside the class body and are available on instances of the class. Here’s an example of defining methods inside a class:\r\n\r\n```js\r\nclass Person {  \r\n  constructor(name, age) {  \r\n    this.name = name;  \r\n    this.age = age;  \r\n  }  \r\nsayHello() {  \r\n    console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);  \r\n  }  \r\n}  \r\nconst john = new Person('John', 30);  \r\njohn.sayHello(); // \"Hello, my name is John and I am 30 years old.\"\r\n```\r\n\r\nStatic Methods and Properties\r\n=============================\r\n\r\nIn JavaScript classes, static methods and properties are defined using the `**static**` keyword. Static methods and properties are associated with the class itself, rather than with instances of the class. Here's an example of defining static methods and properties in a class:\r\n\r\n```\r\nclass Person {  \r\n  constructor(name, age) {  \r\n    this.name = name;  \r\n    this.age = age;  \r\n  }  \r\nsayHello() {  \r\n    console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);  \r\n  }  \r\n  static create(name, age) {  \r\n    return new Person(name, age);  \r\n  }  \r\n  static defaultOccupation = 'Software Developer';  \r\n}  \r\nconsole.log(Person.defaultOccupation); // \"Software Developer\"  \r\nconst john = Person.create('John', 30);  \r\njohn.sayHello(); // \"Hello, my name is John and I am 30 years old.\"\r\n```\r\n\r\nConstructor Parameters\r\n======================\r\n\r\nIn JavaScript classes, the `**constructor**` method is a special method that is called when an instance of the class is created. The `**constructor**` method is used to initialize the instance properties of the class.\r\n\r\n```\r\nclass Person {  \r\n  constructor(name, age) {  \r\n    this.name = name;  \r\n    this.age = age;  \r\n  }  \r\n}\r\n```\r\n\r\nYou can also use the `**constructor**` method to perform additional setup tasks or to check the validity of the arguments. For example:\r\n\r\n```\r\nclass Person {  \r\n  constructor(name, age) {  \r\n    if (typeof name !== 'string') {  \r\n      throw new TypeError('Name must be a string');  \r\n    }  \r\nif (typeof age !== 'number') {  \r\n      throw new TypeError('Age must be a number');  \r\n    }  \r\n    this.name = name;  \r\n    this.age = age;  \r\n  }  \r\n  sayHello() {  \r\n    console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);  \r\n  }  \r\n}\r\n```\r\n\r\nInheritance\r\n===========\r\n\r\nInheritance is an important concept in object-oriented programming that allows you to create new classes based on existing classes. In JavaScript, you can use the `**extends**` keyword to create a subclass that inherits from a superclass.\r\n\r\n```\r\nclass Animal {  \r\n  constructor(name) {  \r\n    this.name = name;  \r\n  }  \r\nspeak() {  \r\n    console.log(`${this.name} makes a noise.`);  \r\n  }  \r\n}  \r\nclass Dog extends Animal {  \r\n  speak() {  \r\n    console.log(`${this.name} barks.`);  \r\n  }  \r\n}  \r\nclass Cat extends Animal {  \r\n  speak() {  \r\n    console.log(`${this.name} meows.`);  \r\n  }  \r\n}  \r\nconst dog = new Dog('Fido');  \r\nconst cat = new Cat('Whiskers');  \r\ndog.speak(); // \"Fido barks.\"  \r\ncat.speak(); // \"Whiskers meows.\"\r\n```\r\n\r\nInheritance in JavaScript allows you to reuse code and create a hierarchy of classes with different levels of specificity. You can also extend from built-in class.\r\n\r\n```\r\nclass MyArray extends Array {  \r\n  constructor(...args) {  \r\n    super(...args);  \r\n  }  \r\ngetFirst() {  \r\n    return this[0];  \r\n  }  \r\n  getLast() {  \r\n    return this[this.length - 1];  \r\n  }  \r\n}  \r\nconst myArray = new MyArray(1, 2, 3, 4, 5);  \r\nconsole.log(myArray.getFirst()); // 1  \r\nconsole.log(myArray.getLast()); // 5  \r\nconsole.log(myArray instanceof Array); // true  \r\nconsole.log(myArray instanceof MyArray); // true\r\n```\r\n\r\nOverriding Methods\r\n==================\r\n\r\nIn object-oriented programming, method overriding is the process of defining a method in a subclass that has the same name and signature as a method in its superclass. The purpose of overriding a method is to change its implementation in the subclass to provide specialized behavior.\r\n\r\nIn JavaScript, you can override a method in a subclass by simply defining a new method with the same name as the method you want to override. Here’s an example:\r\n\r\n```\r\nclass Animal {  \r\n  speak() {  \r\n    console.log('The animal makes a noise.');  \r\n  }  \r\n}  \r\nclass Dog extends Animal {  \r\n  speak() {  \r\n    console.log('The dog barks.');  \r\n  }  \r\n}  \r\nconst dog = new Dog();  \r\ndog.speak(); // \"The dog barks.\"\r\n```\r\n\r\nCalling Superclass Methods\r\n==========================\r\n\r\nThe `**super**` keyword is used in JavaScript to access and call functions or methods in a parent or superclass.\r\n\r\nWhen you define a class that extends another class, you can use the `**super**` keyword to call the constructor and methods of the parent class. Here's an example:\r\n\r\n```\r\nclass Animal {  \r\n  constructor(name) {  \r\n    this.name = name;  \r\n  }  \r\nspeak() {  \r\n    console.log(`${this.name} makes a noise.`);  \r\n  }  \r\n}  \r\nclass Dog extends Animal {  \r\n  constructor(name) {  \r\n    super(name);  \r\n  }  \r\n  speak() {  \r\n    super.speak();  \r\n    console.log(`${this.name} barks.`);  \r\n  }  \r\n}  \r\nconst dog = new Dog('Fido');  \r\ndog.speak(); // \"Fido makes a noise.\" \"Fido barks.\"\r\n```\r\n\r\nPrivate and Protected Fields\r\n============================\r\n\r\nJavaScript does not have built-in support for private and protected properties in classes, but the `**#**` symbol can be used to denote private fields in more recent versions of JavaScript (ES2022 or later).\r\n\r\nIn JavaScript, protected properties are typically denoted by prefixing their names with an underscore, like `**_name**` or `**_age**`. This convention indicates that the property should not be accessed or modified from outside the class, but can still be accessed and modified by subclasses.\r\n\r\n```\r\nclass Person {  \r\n  #name;  \r\n  _age;  \r\nconstructor(name, age) {  \r\n    this.#name = name;  \r\n    this._age = age;  \r\n  }  \r\n  sayHello() {  \r\n    console.log(`Hello, my name is ${this.#name} and I am ${this._age} years old.`);  \r\n  }  \r\n}  \r\nclass Employee extends Person {  \r\n  #salary;  \r\n  constructor(name, age, salary) {  \r\n    super(name, age);  \r\n    this.#salary = salary;  \r\n  }  \r\n  sayHello() {  \r\n    console.log(`Hello, my name is ${this.#name} and I am ${this._age} years old. My salary is ${this.#salary}.`);  \r\n  }  \r\n}  \r\nconst john = new Person('John', 30);  \r\nconsole.log(john.#name); // This will cause a syntax error since #name is private  \r\nconsole.log(john._age); // \"30\" - this is technically allowed but goes against the convention of protected properties  \r\nconst bob = new Employee('Bob', 35, 50000);  \r\nconsole.log(bob.#salary); // This will cause a syntax error since #salary is private  \r\nbob.sayHello(); // \"Hello, my name is Bob and I am 35 years old. My salary is 50000.\"\r\n```\r\n\r\nGetter and Setter\r\n=================\r\n\r\nGetters and setters are methods in JavaScript classes that allow you to control access to an object’s properties.\r\n\r\nA getter is a method that gets the value of a property. It is defined using the `**get**` keyword and can be used to access a property without directly accessing it. A setter is a method that sets the value of a property. It is defined using the `**set**` keyword and can be used to set the value of a property using a function call. Here's an example:\r\n\r\n```\r\nclass Person {  \r\n  constructor(name) {  \r\n    this.#name = name;  \r\n  }  \r\nget name() {  \r\n    return this.#name.toUpperCase();  \r\n  }  \r\n  set name(newName) {  \r\n    this.#name = newName.toLowerCase();  \r\n  }  \r\n}  \r\nconst person = new Person('John');  \r\nconsole.log(person.name); // \"JOHN\"  \r\nperson.name = 'Jane';  \r\nconsole.log(person.name); // \"jane\"\r\n```\r\n\r\n`instanceof` method\r\n===================\r\n\r\n`**instanceof**` is a built-in operator in JavaScript that allows you to check whether an object is an instance of a particular class or constructor function. It returns a boolean value indicating whether the object is an instance of the specified class.\r\n\r\n```\r\nclass Person {  \r\n  constructor(name) {  \r\n    this.name = name;  \r\n  }  \r\n}  \r\nclass Student extends Person {  \r\n  constructor(name, grade) {  \r\n    super(name);  \r\n    this.grade = grade;  \r\n  }  \r\n}  \r\nconst person = new Person('John');  \r\nconst student = new Student('Jane', 10);  \r\nconsole.log(person instanceof Person); // true  \r\nconsole.log(person instanceof Student); // false  \r\nconsole.log(student instanceof Person); // true  \r\nconsole.log(student instanceof Student); // true\r\n```\r\n\r\nConclusion\r\n==========\r\n\r\nClasses in JavaScript provide a way to define objects with properties and methods. They are a powerful tool for organizing code and creating reusable components. With the ability to inherit from other classes, JavaScript classes provide a flexible and extensible programming model."},{"id":"advanced-datatypes-in-js","metadata":{"permalink":"/blog/advanced-datatypes-in-js","editUrl":"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/15-advanced-datatypes-in-js.md","source":"@site/blog/javascript/15-advanced-datatypes-in-js.md","title":"Advanced Datatypes in JS","description":"JavaScript is an object-oriented programming language that has been around for quite some time now. It allows developers to create complex applications with ease. While working with JavaScript, developers often come across data types that are not commonly found in other programming languages. In this blog post, we will explore some of the advanced data types in JavaScript, including Map, Set, and Date.","date":"2024-05-16T10:39:22.000Z","tags":[{"label":"javascript","permalink":"/blog/tags/javascript"}],"readingTime":5.345,"hasTruncateMarker":true,"authors":[{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"}],"frontMatter":{"slug":"advanced-datatypes-in-js","title":"Advanced Datatypes in JS","authors":{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"},"tags":["javascript"]},"unlisted":false,"prevItem":{"title":"Class in JS","permalink":"/blog/class-in-js"},"nextItem":{"title":"Error Handling in JS","permalink":"/blog/error-handling-in-js"}},"content":"JavaScript is an object-oriented programming language that has been around for quite some time now. It allows developers to create complex applications with ease. While working with JavaScript, developers often come across data types that are not commonly found in other programming languages. In this blog post, we will explore some of the advanced data types in JavaScript, including Map, Set, and Date.\r\n<!-- truncate -->\r\n\r\nMap\r\n===\r\n\r\nIn JavaScript, the `**Map**` data type is an object that allows you to store key-value pairs, where the key and value can be of any data type. Unlike regular objects, `**Map**` maintains the order of key-value pairs and provides various methods to access and manipulate the data.\r\n\r\nHere is an example of how to create a new `**Map**` object:\r\n\r\n```js\r\nconst myMap = new Map();\r\n```\r\n\r\nYou can add new key-value pairs to a `**Map**` using the `**set()**` method:\r\n\r\n```js\r\nmyMap.set('key1', 'value1');  \r\nmyMap.set(2, 'value2');  \r\nmyMap.set(true, 'value3');\r\n```\r\n\r\nYou can also chain the `**set()**` method to add multiple key-value pairs in a single line:\r\n\r\n```js\r\nmyMap.set('key4', 'value4').set('key5', 'value5');\r\n```\r\n\r\nTo access the value of a key in a `**Map**`, you can use the `**get()**` method:\r\n\r\n```js\r\nconsole.log(myMap.get('key1')); // displays 'value1'  \r\nconsole.log(myMap.get(2)); // displays 'value2'  \r\nconsole.log(myMap.get(true)); // displays 'value3'\r\n```\r\n\r\nYou can check if a key exists in a `**Map**` using the `**has()**` method:\r\n\r\n```js\r\nconsole.log(myMap.has('key1')); // displays true  \r\nconsole.log(myMap.has('key3')); // displays false\r\n```\r\n\r\nYou can also remove a key-value pair from a `**Map**` using the `**delete()**` method:\r\n\r\n```js\r\nmyMap.delete('key1');  \r\nconsole.log(myMap.has('key1')); // displays false\r\n```\r\n\r\n`**Map**` objects have a `**size**` property that returns the number of key-value pairs in the map:\r\n\r\n```js\r\nconsole.log(myMap.size); // displays 5\r\n```\r\n\r\nOne of the most powerful features of `**Map**` is the ability to use any data type as keys. For example, you can use objects, arrays, or even functions as keys:\r\n\r\n```js\r\nconst myObj = {name: 'John', age: 30};  \r\nconst myFunc = () => console.log('Hello!');  \r\nmyMap.set(myObj, 'value6');  \r\nmyMap.set(myFunc, 'value7');  \r\nconsole.log(myMap.get(myObj)); // displays 'value6'  \r\nconsole.log(myMap.get(myFunc)); // displays 'value7'\r\n```\r\n\r\nOverall, the `**Map**` data type is a versatile and powerful tool for storing and manipulating key-value pairs in JavaScript.\r\n\r\nSet\r\n===\r\n\r\nIn JavaScript, the `**Set**` data type is an object that allows you to store unique values of any data type, whether primitive values or object references. Unlike arrays, `**Set**` maintains the order of elements and ensures that each element is unique.\r\n\r\nHere is an example of how to create a new `**Set**` object:\r\n\r\n```js\r\nconst mySet = new Set();\r\n```\r\n\r\nYou can add elements to a `**Set**` using the `**add()**` method:\r\n\r\n```js\r\nmySet.add('value1');  \r\nmySet.add(2);  \r\nmySet.add(true);\r\n```\r\n\r\nYou can also chain the `**add()**` method to add multiple elements in a single line:\r\n\r\n```js\r\nmySet.add('value4').add('value5');\r\n```\r\n\r\nTo access elements in a `**Set**`, you can use the `**has()**` method:\r\n\r\n```js\r\nconsole.log(mySet.has('value1')); // displays true  \r\nconsole.log(mySet.has(2)); // displays true  \r\nconsole.log(mySet.has(false)); // displays false\r\n```\r\n\r\nYou can remove elements from a `**Set**` using the `**delete()**` method:\r\n\r\n```js\r\nmySet.delete('value1');  \r\nconsole.log(mySet.has('value1')); // displays false\r\n```\r\n\r\n`**Set**` objects have a `**size**` property that returns the number of elements in the set:\r\n\r\n```js\r\nconsole.log(mySet.size); // displays 4\r\n```\r\n\r\nOne of the most powerful features of `**Set**` is the ability to use any data type as elements. For example, you can use objects, arrays, or even functions as elements:\r\n\r\n```js\r\nconst myObj = {name: 'John', age: 30};  \r\nconst myFunc = () => console.log('Hello!');  \r\nmySet.add(myObj);  \r\nmySet.add(myFunc);  \r\nconsole.log(mySet.has(myObj)); // displays true  \r\nconsole.log(mySet.has(myFunc)); // displays true\r\n```\r\n\r\nYou can also iterate through the elements of a `**Set**` using the `**forEach()**` method or a `**for...of**` loop:\r\n\r\n```js\r\nmySet.forEach((value) => console.log(value));  \r\n// displays 'value4', 'value5', {name: 'John', age: 30}, and the function myFunc  \r\nfor (const value of mySet) {  \r\n  console.log(value);  \r\n}  \r\n// same as above\r\n```\r\n\r\nOverall, the `**Set**` data type is a useful tool for storing and manipulating unique elements of any data type in JavaScript.\r\n\r\nDate\r\n====\r\n\r\nIn JavaScript, the `**Date**` data type is used to represent dates and times. The `**Date**` object is based on a time value that is the number of milliseconds since January 1, 1970, 00:00:00 UTC (Coordinated Universal Time).\r\n\r\nHere is an example of how to create a new `**Date**` object:\r\n\r\n```js\r\nconst currentDate = new Date();\r\n```\r\n\r\nThis will create a `**Date**` object representing the current date and time.\r\n\r\nYou can also create a `**Date**` object by passing a specific date and time as a string to the `**Date**` constructor. The string must be in a format recognized by the `**Date.parse()**` method. For example:\r\n\r\n```js\r\nconst specificDate = new Date('March 10, 2023 10:30:00');\r\n```\r\n\r\nThis will create a `**Date**` object representing the date and time March 10, 2023 at 10:30:00 AM.\r\n\r\nOnce you have a `**Date**` object, you can use various methods to get or set specific parts of the date and time. Here are some examples:\r\n\r\n```js\r\nconst currentDate = new Date();  \r\n// get the year  \r\nconst year = currentDate.getFullYear(); // returns 2023  \r\n// get the month (0-indexed)  \r\nconst month = currentDate.getMonth(); // returns 2 (March)  \r\n// get the day of the month  \r\nconst day = currentDate.getDate(); // returns 10  \r\n// get the day of the week (0-indexed, with Sunday being 0)  \r\nconst dayOfWeek = currentDate.getDay(); // returns 5 (Friday)  \r\n// get the hour  \r\nconst hour = currentDate.getHours(); // returns 10  \r\n// get the minutes  \r\nconst minutes = currentDate.getMinutes(); // returns 45  \r\n// get the seconds  \r\nconst seconds = currentDate.getSeconds(); // returns 30  \r\n// get the milliseconds  \r\nconst milliseconds = currentDate.getMilliseconds(); // returns 0\r\n```\r\n\r\nYou can also set specific parts of the date and time using methods like `**setFullYear()**`, `**setMonth()**`, `**setDate()**`, `**setHours()**`, `**setMinutes()**`, `**setSeconds()**`, and `**setMilliseconds()**`.\r\n\r\n```js\r\ncurrentDate.setFullYear(2024); // set the year to 2024\r\n```\r\n\r\nYou can also use the `**getTime()**` method to get the number of milliseconds since January 1, 1970, 00:00:00 UTC, and the `**setTime()**` method to set the date and time based on a specified number of milliseconds.\r\n\r\n```js\r\nconst timestamp = currentDate.getTime(); // get the number of milliseconds since 1970  \r\nconst newDate = new Date();  \r\nnewDate.setTime(timestamp); // set the date and time based on the timestamp\r\n```\r\n\r\nIn addition, the `**Date**` object provides various methods for formatting and parsing dates and times. For example, the `**toLocaleString()**` method returns a string representation of the date and time in a specific locale format.\r\n\r\n```js\r\nconst currentDate = new Date();  \r\nconst formattedDate = currentDate.toLocaleString('en-US'); // returns \"3/10/2023, 10:45:30 AM\"\r\n```\r\n\r\nOverall, the `**Date**` data type in JavaScript provides a powerful and flexible way to work with dates and times in your code."},{"id":"error-handling-in-js","metadata":{"permalink":"/blog/error-handling-in-js","editUrl":"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/16-error-handling-in-js.md","source":"@site/blog/javascript/16-error-handling-in-js.md","title":"Error Handling in JS","description":"JavaScript is a programming language that is widely used for creating dynamic and interactive web pages. Like other programming languages, it is important to handle errors that may occur during the execution of JavaScript code.","date":"2024-05-16T10:39:22.000Z","tags":[{"label":"javascript","permalink":"/blog/tags/javascript"}],"readingTime":5.07,"hasTruncateMarker":true,"authors":[{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"}],"frontMatter":{"slug":"error-handling-in-js","title":"Error Handling in JS","authors":{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"},"tags":["javascript"]},"unlisted":false,"prevItem":{"title":"Advanced Datatypes in JS","permalink":"/blog/advanced-datatypes-in-js"},"nextItem":{"title":"Scheduling in JS","permalink":"/blog/scheduling-in-js"}},"content":"JavaScript is a programming language that is widely used for creating dynamic and interactive web pages. Like other programming languages, it is important to handle errors that may occur during the execution of JavaScript code.\r\n<!-- truncate -->\r\n\r\nTypes of Errors in JS\r\n=====================\r\n\r\nThere are three types of errors that can occur in JavaScript code:\r\n\r\n1.  **Syntax Errors**: These are errors that occur when there is a mistake in the syntax of the code. For example, missing semicolons or brackets can cause syntax errors.\r\n2.  **Runtime Errors**: These are errors that occur during the execution of the code. For example, trying to access an undefined variable can cause a runtime error.\r\n3.  **Logical Errors**: These are errors that occur when the code does not do what it is supposed to do. For example, a function that returns the wrong value.\r\n\r\nError Handling Techniques in JS\r\n===============================\r\n\r\nThere are several techniques that can be used to handle errors in JavaScript code:\r\n\r\nTry-Catch Statement\r\n===================\r\n\r\nIn JavaScript, the try-catch statement is used to handle exceptions or errors that may occur in a block of code. The try block contains the code that may cause an exception, and the catch block handles the exception if it is thrown.\r\n\r\nHere’s the basic syntax of the try-catch statement in JavaScript:\r\n\r\n```js\r\ntry {  \r\n  // code that may cause an exception  \r\n} catch (error) {  \r\n  // code to handle the exception  \r\n}\r\n```\r\n\r\nThe `**try**` block contains the code that may cause an exception. If an exception is thrown, JavaScript will jump out of the `**try**` block and into the `**catch**` block. The `**catch**` block takes an error object as a parameter, which contains information about the exception that was thrown.\r\n\r\nHere’s an example that demonstrates the use of the try-catch statement in JavaScript:\r\n\r\n```js\r\njavascriptCopy code  \r\nfunction divide(a, b) {  \r\n  try {  \r\n    if (b === 0) {  \r\n      throw new Error('Cannot divide by zero');  \r\n    }  \r\n    return a / b;  \r\n  } catch (error) {  \r\n    console.log(error.message);  \r\n    return null;  \r\n  }  \r\n}  \r\nconsole.log(divide(10, 5)); // Output: 2  \r\nconsole.log(divide(10, 0)); // Output: Cannot divide by zero, null\r\n```\r\n\r\nWhen an exception is thrown and caught using a `**catch**` block, the `**catch**` block receives an `**error**` object that contains information about the exception that was thrown. The `**error**` object has several properties that you can use to get more information about the exception. Some of the most commonly used properties are:\r\n\r\n*   `**message**`: A string that contains a description of the exception.\r\n*   `**name**`: A string that contains the name of the exception. This is usually the name of the constructor function that was used to create the exception.\r\n*   `**stack**`: A string that contains a stack trace of the call stack at the time the exception was thrown. This can be useful for debugging purposes.\r\n\r\nHere is an example that demonstrates how to use the `**error**` object to handle an exception:\r\n\r\n```js\r\ntry {  \r\n  // Some code that might throw an exception  \r\n} catch (error) {  \r\n  console.error('An error occurred:', error.message);  \r\n  console.error('Error name:', error.name);  \r\n  console.error('Stack trace:', error.stack);  \r\n}\r\n```\r\n\r\nThrow Statement\r\n===============\r\n\r\nIn JavaScript, the `**throw**` statement is used to throw an exception. When an exception is thrown, the JavaScript interpreter immediately stops executing the current function and looks for the nearest exception handling code to catch and handle the exception.\r\n\r\nThe basic syntax for the `**throw**` statement is as follows:\r\n\r\n```js\r\nthrow expression;\r\n```\r\n\r\nThe `**expression**` can be any value or object that represents the exception that you want to throw. For example, you can throw a string, a number, an object, or an error.\r\n\r\nHere is an example that demonstrates how to use the `**throw**` statement to throw a custom error message:\r\n\r\n```js\r\nfunction divide(a, b) {  \r\n  if (b === 0) {  \r\n    throw 'Cannot divide by zero';  \r\n  }  \r\n  return a / b;  \r\n}  \r\nconsole.log(divide(10, 0)); // Throws \"Cannot divide by zero\" exception\r\n```\r\n\r\nFinally Block\r\n=============\r\n\r\nThe `**finally**` block is a part of a `**try...catch**` statement in JavaScript. It is used to execute code that should always run, regardless of whether an exception was thrown or not. The `**finally**` block is optional, but if it is present, it is always executed, even if there is no `**catch**` block.\r\n\r\nHere’s an example:\r\n\r\n```js\r\ntry {  \r\n  // Code that may throw an exception  \r\n  // ...  \r\n} catch (error) {  \r\n  // Code to handle the exception  \r\n  // ...  \r\n} finally {  \r\n  // Code that should always run  \r\n  // ...  \r\n}\r\n```\r\n\r\nIn this example, the `**try**` block contains code that may throw an exception. If an exception is thrown, the `**catch**` block is executed to handle it. If there is no exception, the `**catch**` block is skipped.\r\n\r\nRegardless of whether an exception was thrown or not, the code in the `**finally**` block is always executed. This can be useful for performing cleanup tasks, such as closing files or releasing resources.\r\n\r\nHere’s an example of how you could use the `**finally**` block:\r\n\r\n```js\r\nfunction divide(a, b) {  \r\n  try {  \r\n    return a / b;  \r\n  } catch (error) {  \r\n    console.error('An error occurred:', error);  \r\n  } finally {  \r\n    console.log('Division operation completed');  \r\n  }  \r\n}  \r\nconsole.log(divide(10, 2));  // Output: 5  \r\nconsole.log(divide(10, 0));  // Output: Infinity\r\n```\r\n\r\nCustom Error Class\r\n==================\r\n\r\nIn JavaScript, you can create custom error classes by extending the built-in `**Error**` class. This can be useful when you want to create specific types of errors for your application that have their own unique properties and behaviors. Here's an example of how you can create a custom error class:\r\n\r\n```js\r\nclass MyError extends Error {  \r\n  constructor(message, code) {  \r\n    super(message);  \r\n    this.code = code;  \r\n    this.name = 'MyError';  \r\n  }  \r\n}\r\n```\r\n\r\nHere’s an example of how you can use this custom error class:\r\n\r\n```js\r\nfunction myFunction() {  \r\n  throw new MyError('An error occurred', 500);  \r\n}  \r\ntry {  \r\n  myFunction();  \r\n} catch (error) {  \r\n  console.error(error.name);    // Output: \"MyError\"  \r\n  console.error(error.message); // Output: \"An error occurred\"  \r\n  console.error(error.code);    // Output: 500  \r\n}\r\n```\r\n\r\nIn conclusion, error handling is an important part of writing JavaScript code. By using techniques such as try-catch statements, throw statements, and finally blocks, you can effectively handle errors that may occur during the execution of your code."},{"id":"scheduling-in-js","metadata":{"permalink":"/blog/scheduling-in-js","editUrl":"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/17-scheduling-in-js.md","source":"@site/blog/javascript/17-scheduling-in-js.md","title":"Scheduling in JS","description":"JavaScript is a programming language that is widely used for building web applications. One of the important features of JavaScript is scheduling, which allows developers to execute code at a specific time or after a certain interval.","date":"2024-05-16T10:39:22.000Z","tags":[{"label":"javascript","permalink":"/blog/tags/javascript"}],"readingTime":1.425,"hasTruncateMarker":true,"authors":[{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"}],"frontMatter":{"slug":"scheduling-in-js","title":"Scheduling in JS","authors":{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"},"tags":["javascript"]},"unlisted":false,"prevItem":{"title":"Error Handling in JS","permalink":"/blog/error-handling-in-js"},"nextItem":{"title":"Asynchronous Programming in JS","permalink":"/blog/asynchronous-programming-in-js"}},"content":"JavaScript is a programming language that is widely used for building web applications. One of the important features of JavaScript is scheduling, which allows developers to execute code at a specific time or after a certain interval.\r\n<!-- truncate -->\r\n\r\nsetTimeout()\r\n============\r\n\r\nThe `setTimeout()` function is used to execute a function after a certain delay. The delay is specified in milliseconds. Here is an example of using `setTimeout()`:\r\n\r\n```js\r\nsetTimeout(function() {  \r\n  console.log(\"Hello, World!\");  \r\n}, 3000);\r\n```\r\n\r\nIn this example, the function `console.log()` will be executed after a delay of 3 seconds.\r\n\r\nsetInterval()\r\n=============\r\n\r\nThe `setInterval()` function is used to execute a function repeatedly after a certain interval. The interval is specified in milliseconds. Here is an example of using `setInterval()`:\r\n\r\n```js\r\nsetInterval(function() {  \r\n  console.log(\"Hello, World!\");  \r\n}, 1000);\r\n```\r\n\r\nIn this example, the function `console.log()` will be executed every 1 second.\r\n\r\nclearTimeout()\r\n==============\r\n\r\nThe `clearTimeout()` function is used to cancel a `setTimeout()` function. Here is an example of using `clearTimeout()`:\r\n\r\n```js\r\nvar timeoutID = setTimeout(function() {  \r\n  console.log(\"Hello, World!\");  \r\n}, 3000);  \r\nclearTimeout(timeoutID);\r\n```\r\n\r\nIn this example, the `setTimeout()` function will be cancelled before it has a chance to execute.\r\n\r\nclearInterval()\r\n===============\r\n\r\nThe `clearInterval()` function is used to cancel a `setInterval()` function. Here is an example of using `clearInterval()`:\r\n\r\n```js\r\nvar intervalID = setInterval(function() {  \r\n  console.log(\"Hello, World!\");  \r\n}, 1000);  \r\nclearInterval(intervalID);\r\n```\r\n\r\nIn this example, the `setInterval()` function will be cancelled and the code inside the function will no longer be executed.\r\n\r\nIn conclusion, scheduling is an important feature of JavaScript that allows developers to execute code at a specific time or after a certain interval. The `setTimeout()` and `setInterval()` functions are used to achieve this functionality. Additionally, the `clearTimeout()` and `clearInterval()` functions are used to cancel scheduled functions."},{"id":"asynchronous-programming-in-js","metadata":{"permalink":"/blog/asynchronous-programming-in-js","editUrl":"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/18-asynchronous-programming-in-js.md","source":"@site/blog/javascript/18-asynchronous-programming-in-js.md","title":"Asynchronous Programming in JS","description":"Asynchronous programming is a way of writing non-blocking code in JavaScript. In traditional programming, code runs sequentially from top to bottom, which means that one line of code is executed at a time. However, when dealing with long-running tasks such as network requests or file I/O, synchronous programming can lead to unresponsive applications.","date":"2024-05-16T10:39:22.000Z","tags":[{"label":"javascript","permalink":"/blog/tags/javascript"}],"readingTime":5.885,"hasTruncateMarker":true,"authors":[{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"}],"frontMatter":{"slug":"asynchronous-programming-in-js","title":"Asynchronous Programming in JS","authors":{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"},"tags":["javascript"]},"unlisted":false,"prevItem":{"title":"Scheduling in JS","permalink":"/blog/scheduling-in-js"},"nextItem":{"title":"Call Stack and Callback Queue in JS","permalink":"/blog/call-stack-and-callback-queue-in-js"}},"content":"Asynchronous programming is a way of writing non-blocking code in JavaScript. In traditional programming, code runs sequentially from top to bottom, which means that one line of code is executed at a time. However, when dealing with long-running tasks such as network requests or file I/O, synchronous programming can lead to unresponsive applications.\r\n<!-- truncate -->\r\n\r\nBackground\r\n==========\r\n\r\nAsynchronous programming is necessary in JavaScript for several reasons, especially when it comes to web development.\r\n\r\nFirstly, many web applications need to perform I/O operations, such as reading and writing data to databases or making HTTP requests to external APIs. These operations can take a long time to complete, especially if the network connection is slow or the server is under heavy load. If we execute these operations synchronously, they will block the main thread of execution, making the entire application unresponsive until the operation is complete. Asynchronous programming allows us to execute these operations in the background, without blocking the main thread, making the application more responsive and performant.\r\n\r\nSecondly, JavaScript runs on a single thread, which means that it can only execute one task at a time. Asynchronous programming allows us to break up long-running tasks into smaller, asynchronous tasks, which can be executed simultaneously. For example, we can load several images in the background while the main thread is handling user input. This approach makes the application appear more responsive and improves the user experience.\r\n\r\nFinally, JavaScript is frequently used to build real-time applications, such as chat applications or online multiplayer games. In these applications, it is essential to update the UI in real-time, based on data received from the server. Asynchronous programming allows us to receive and process data in the background, without blocking the main thread, and then update the UI when the data is ready. This approach enables real-time updates and improves the overall user experience.\r\n\r\nIn asynchronous programming, we execute tasks without blocking the main thread of execution, allowing for multiple tasks to run simultaneously. JavaScript provides several mechanisms for implementing asynchronous programming, including callbacks, promises, and the newer async/await syntax.\r\n\r\nCallback\r\n========\r\n\r\nCallbacks are the oldest mechanism for implementing asynchronous programming in JavaScript. They are functions that are passed as arguments to other functions and executed once a particular task is complete. Callbacks allow developers to handle asynchronous operations by providing a way to execute code once a particular task has finished. However, as the complexity of the codebase increases, callbacks can become challenging to manage, leading to callback hell, where the code becomes nested and difficult to read.\r\n\r\n```js\r\nfunction add(a, b) {  \r\n  return a + b;  \r\n}  \r\nfunction multiply(a, b, callback) {  \r\n  const result = callback(a, b);  \r\n  console.log(result);  \r\n}  \r\nmultiply(3, 4, add); // Output: 7\r\n```\r\n\r\n`setTimeOut` is an asynchronous function which creates a separate thread to perform function which is happening inside callback of this function.\r\n\r\n```js\r\nfunction fetchData(callback) {  \r\n  // Simulate a delay of 2 seconds (2000 milliseconds)  \r\n  setTimeout(function() {  \r\n    const data = {  \r\n      name: \"John Doe\",  \r\n      age: 30,  \r\n      city: \"New York\"  \r\n    };  \r\n    callback(data);  \r\n  }, 2000);  \r\nconsole.log(\"Fetching data...\");  \r\n}  \r\nfunction displayData(data) {  \r\n  // Log the data to the console  \r\n  console.log(data);  \r\n}  \r\n// Fetch the data and display it using the displayData callback function  \r\nfetchData(displayData);  \r\n// Fetching data...  \r\n// {name: \"John Doe\", age: 30, city: \"New York\"}\r\n```\r\n\r\nCallback Hell\r\n=============\r\n\r\nCallback hell is a term used to describe deeply nested and difficult-to-read code that arises from using multiple levels of callbacks in JavaScript. Here’s an example of callback hell:\r\n\r\n```js\r\nfunction operation1(callback1) {  \r\n  // First level of nesting  \r\n  setTimeout(function() {  \r\n    console.log('Operation 1');  \r\n    callback1();  \r\n  }, 1000);  \r\n}  \r\nfunction operation2(callback2) {  \r\n  // Second level of nesting  \r\n  setTimeout(function() {  \r\n    console.log('Operation 2');  \r\n    callback2();  \r\n  }, 1000);  \r\n}  \r\nfunction operation3(callback3) {  \r\n  // Third level of nesting  \r\n  setTimeout(function() {  \r\n    console.log('Operation 3');  \r\n    callback3();  \r\n  }, 1000);  \r\n}  \r\noperation1(function() {  \r\n  operation2(function() {  \r\n    operation3(function() {  \r\n      console.log('All operations completed!');  \r\n    });  \r\n  });  \r\n});\r\n```\r\n\r\nPromise\r\n=======\r\n\r\nPromises were introduced in ECMAScript 6 as an alternative to callbacks. A promise is an object representing the eventual completion or failure of an asynchronous operation. They provide a more flexible and expressive way to write asynchronous code than callbacks, as they allow developers to chain multiple asynchronous operations and handle errors in a more structured and easy-to-read manner. Promises are easier to manage than callbacks, but they still require a fair amount of boilerplate code.\r\n\r\n```js\r\nfunction fetchData() {  \r\n  return new Promise(function(resolve, reject) {  \r\n    // Simulate a delay of 2 seconds (2000 milliseconds)  \r\n    setTimeout(function() {  \r\n      const data = {  \r\n        name: \"John Doe\",  \r\n        age: 30,  \r\n        city: \"New York\"  \r\n      };  \r\nif (data) {  \r\n        resolve(data);  \r\n      } else {  \r\n        reject(\"Error fetching data.\");  \r\n      }  \r\n    }, 2000);  \r\n  });  \r\n}  \r\nfetchData()  \r\n  .then(function(data) {  \r\n    console.log(data);  \r\n  })  \r\n  .catch(function(error) {  \r\n    console.log(error);  \r\n  });\r\n```\r\n\r\nPromise Chaining\r\n================\r\n\r\nPromise chaining is a technique for managing multiple asynchronous operations in a specific order using Promises. It involves returning a Promise from a `**then()**` callback function, which can then be chained with another `**then()**` function.\r\n\r\nWhen chaining Promises, each `**then()**` callback function is executed after the previous Promise has resolved. The result of the previous Promise is passed as an argument to the `**then()**` callback function, which can then return a new Promise to continue the chain.\r\n\r\nBy chaining Promises together, we can perform a series of asynchronous operations in a specific order, without having to nest multiple callback functions within each other (known as “callback hell”). This makes the code easier to read and maintain.\r\n\r\n```js\r\nfunction fetchUserData() {  \r\n  return new Promise(function(resolve, reject) {  \r\n    setTimeout(function() {  \r\n      const userData = {  \r\n        name: \"John Doe\",  \r\n        age: 30,  \r\n        city: \"New York\"  \r\n      };  \r\nif (userData) {  \r\n        resolve(userData);  \r\n      } else {  \r\n        reject(\"Error fetching user data.\");  \r\n      }  \r\n    }, 2000);  \r\n  });  \r\n}  \r\nfunction fetchOrdersData(userId) {  \r\n  return new Promise(function(resolve, reject) {  \r\n    setTimeout(function() {  \r\n      const ordersData = {  \r\n        id: \"123456\",  \r\n        userId: userId,  \r\n        items: [\"item1\", \"item2\", \"item3\"],  \r\n        totalPrice: 100  \r\n      };  \r\n      if (ordersData) {  \r\n        resolve(ordersData);  \r\n      } else {  \r\n        reject(\"Error fetching orders data.\");  \r\n      }  \r\n    }, 2000);  \r\n  });  \r\n}  \r\nfetchUserData()  \r\n  .then(function(userData) {  \r\n    console.log(userData);  \r\n    return fetchOrdersData(userData.id);  \r\n  })  \r\n  .then(function(ordersData) {  \r\n    console.log(ordersData);  \r\n  })  \r\n  .catch(function(error) {  \r\n    console.log(error);  \r\n  });\r\n```\r\n\r\n`async` / `await`\r\n=================\r\n\r\nThe async/await syntax, introduced in ECMAScript 2017, provides a cleaner and more concise way of working with promises. Async/await is built on top of promises, and it allows developers to write asynchronous code that looks more like synchronous code. Async/await uses the keywords `**async**` and `**await**` to manage promises, making it easier to handle errors and write cleaner code. It is quickly becoming the preferred way of handling asynchronous programming in JavaScript.\r\n\r\n```js\r\nfunction fetchData() {  \r\n  return new Promise(function(resolve, reject) {  \r\n    // Simulate a delay of 2 seconds (2000 milliseconds)  \r\n    setTimeout(function() {  \r\n      const data = {  \r\n        name: \"John Doe\",  \r\n        age: 30,  \r\n        city: \"New York\"  \r\n      };  \r\nif (data) {  \r\n        resolve(data);  \r\n      } else {  \r\n        reject(\"Error fetching data.\");  \r\n      }  \r\n    }, 2000);  \r\n  });  \r\n}  \r\nasync function getData() {  \r\n  try {  \r\n    const data = await fetchData();  \r\n    console.log(data);  \r\n  } catch (error) {  \r\n    console.log(error);  \r\n  }  \r\n}  \r\ngetData();\r\n```\r\n\r\nIn conclusion, asynchronous programming is a powerful technique that allows JavaScript to handle long-running tasks without disrupting the user experience. By using callbacks, promises, and async/await, developers can write more efficient and maintainable code, resulting in better performing applications."},{"id":"call-stack-and-callback-queue-in-js","metadata":{"permalink":"/blog/call-stack-and-callback-queue-in-js","editUrl":"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/19-call-stack-and-callback-queue-in-js.md","source":"@site/blog/javascript/19-call-stack-and-callback-queue-in-js.md","title":"Call Stack and Callback Queue in JS","description":"JavaScript is a single-threaded language, which means it can only perform one task at a time. However, it is capable of handling multiple tasks simultaneously using the concept of Call Stack. The Call Stack is a mechanism used by the JavaScript engine to keep track of function calls. When a function is called, it is added to the top of the Call Stack, and when it returns, it is removed from the stack.","date":"2024-05-16T10:39:22.000Z","tags":[{"label":"javascript","permalink":"/blog/tags/javascript"}],"readingTime":3.86,"hasTruncateMarker":true,"authors":[{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"}],"frontMatter":{"slug":"call-stack-and-callback-queue-in-js","title":"Call Stack and Callback Queue in JS","authors":{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"},"tags":["javascript"]},"unlisted":false,"prevItem":{"title":"Asynchronous Programming in JS","permalink":"/blog/asynchronous-programming-in-js"},"nextItem":{"title":"Datatypes in JS: Type Conversion","permalink":"/blog/datatypes-in-js-type-conversion"}},"content":"JavaScript is a single-threaded language, which means it can only perform one task at a time. However, it is capable of handling multiple tasks simultaneously using the concept of Call Stack. The Call Stack is a mechanism used by the JavaScript engine to keep track of function calls. When a function is called, it is added to the top of the Call Stack, and when it returns, it is removed from the stack.\r\n<!-- truncate -->\r\n\r\nCall Stack\r\n==========\r\n\r\nConsider the following code example:\r\n\r\n```js\r\nfunction firstFunction() {  \r\n  console.log(\"This is the first function.\");  \r\n}  \r\nfunction secondFunction() {  \r\n  firstFunction();  \r\n  console.log(\"This is the second function.\");  \r\n}  \r\nsecondFunction();\r\n```\r\n\r\nWhen `secondFunction()` is called, it first calls `firstFunction()`, which is added to the top of the Call Stack. Once `firstFunction()` completes its execution, it is removed from the stack, and `secondFunction()` continues its execution, adding itself to the top of the stack. Finally, when `secondFunction()` completes its execution, it is removed from the stack.\r\n\r\nRecursion\r\n=========\r\n\r\nRecursion is a powerful programming technique that can be used to solve complex problems. Recursion is a technique in programming where a function calls itself repeatedly until it reaches a base condition. Recursion is an essential concept in JavaScript and is widely used in various programming scenarios.\r\n\r\n**Direct Recursion**: This is the most common type of recursion, in which a function calls itself directly.\r\n\r\n```js\r\nfunction factorial(n) {  \r\n  if (n === 0) {  \r\n    return 1;  \r\n  } else {  \r\n    return n * factorial(n - 1);  \r\n  }  \r\n}  \r\nconsole.log(factorial(5));\r\n```\r\n\r\n**Indirect Recursion**: In this type of recursion, multiple functions call each other in a circular manner.\r\n\r\n```js\r\nfunction fib1(num) {  \r\n  if (num <= 1) {  \r\n    return num;  \r\n  } else {  \r\n    return fib2(num - 1) + fib1(num - 2);  \r\n  }  \r\n}  \r\nfunction fib2(num) {  \r\n  if (num <= 1) {  \r\n    return num;  \r\n  } else {  \r\n    return fib1(num - 1) + fib2(num - 2);  \r\n  }  \r\n}  \r\nconsole.log(fib1(6)); // 8\r\n```\r\n\r\nRecursion should be used with caution, as it can lead to stack overflow errors if not implemented correctly.\r\n\r\nCallback Queue\r\n==============\r\n\r\nThe Callback Queue is a data structure that holds a queue of functions to be executed. When a function is invoked and its operation is asynchronous, it is added to the Callback Queue instead of blocking the execution of other code. This means that while the asynchronous operation is in progress, other code can continue to execute without interruption.\r\n\r\n```js\r\n// Example of adding a function to the Callback Queue  \r\nsetTimeout(function(){  \r\n  console.log(\"This function is added to the Callback Queue\");  \r\n}, 0);\r\n```\r\n\r\nThe Callback Queue maintains the order in which the functions are added. The first function to be added to the queue will be the first to be executed when the Call Stack is empty. This ensures that the functions are executed in the order they were added to the Callback Queue.\r\n\r\nEvent Loop\r\n==========\r\n\r\nThe Event Loop is a process that constantly checks the Callback Queue for functions to execute. If the Call Stack is empty, it dequeues the first function in the Callback Queue and adds it to the Call Stack for execution.\r\n\r\n```js\r\n// Example of the Event Loop  \r\nfunction firstFunction(){  \r\n  console.log(\"This is the first function\");  \r\n  setTimeout(function(){  \r\n    console.log(\"This is the second function\");  \r\n  }, 0);  \r\n  console.log(\"This is the third function\");  \r\n}  \r\nfirstFunction();\r\n```\r\n\r\nThe Call Stack is a data structure that keeps track of the functions that are currently being executed. When a function is called, it is added to the Call Stack. When a function completes its execution, it is removed from the Call Stack.\r\n\r\nHow they work together\r\n======================\r\n\r\nWhen an asynchronous operation is triggered, a function (the callback function) is added to the Callback Queue. The Event Loop constantly checks the Callback Queue for the next function to execute. Once the Call Stack is emptied, the Event Loop dequeues the first function in the Callback Queue and adds it to the Call Stack for execution.\r\n\r\n```js\r\n// Example of how the Callback Queue and Event Loop work together  \r\nconsole.log(\"Start\");  \r\nsetTimeout(function() {  \r\n  console.log(\"This is the first function\");  \r\n}, 3000);  \r\nsetTimeout(function() {  \r\n  console.log(\"This is the second function\");  \r\n}, 1000);  \r\nconsole.log(\"End\");\r\n```\r\n\r\nThis allows JavaScript to handle asynchronous operations without blocking the execution of other code.\r\n\r\nIn conclusion, the Call Stack is used to keep track of function calls, while Recursion is a technique in programming where a function calls itself repeatedly. The Callback Queue is a data structure that holds a queue of functions to be executed, while the Event Loop is a process that constantly checks the Callback Queue for functions to execute. These concepts allow JavaScript to handle multiple tasks simultaneously without blocking the execution of other code."},{"id":"datatypes-in-js-type-conversion","metadata":{"permalink":"/blog/datatypes-in-js-type-conversion","editUrl":"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/2-datatypes-in-js-type-conversion.md","source":"@site/blog/javascript/2-datatypes-in-js-type-conversion.md","title":"Datatypes in JS: Type Conversion","description":"JavaScript is a dynamically typed language, which means that the data type of a variable is determined at runtime.","date":"2024-05-16T10:39:22.000Z","tags":[{"label":"javascript","permalink":"/blog/tags/javascript"}],"readingTime":2.895,"hasTruncateMarker":true,"authors":[{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"}],"frontMatter":{"slug":"datatypes-in-js-type-conversion","title":"Datatypes in JS: Type Conversion","authors":{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"},"tags":["javascript"]},"unlisted":false,"prevItem":{"title":"Call Stack and Callback Queue in JS","permalink":"/blog/call-stack-and-callback-queue-in-js"},"nextItem":{"title":"Iterator, Generator and Closure in JS","permalink":"/blog/iterator-generator-and-closure-in-js"}},"content":"JavaScript is a dynamically typed language, which means that the data type of a variable is determined at runtime.\r\n<!-- truncate -->\r\n\r\nThe `typeof` keyword is used to determine the data type of a value or variable in JavaScript. For example, `typeof 42` will return `\"number\"`. There are seven primitive data types in JavaScript:\r\n\r\n1.  **Number**: represents numeric values, including integers and floating-point numbers.\r\n\r\n```js\r\nlet age = 30;  \r\n// toFixed()  \r\nlet num = 3.14159;  \r\nlet formattedNum = num.toFixed(2);  \r\nconsole.log(formattedNum); // \"3.14\"  \r\n// toPrecision()  \r\nlet num = 123.456;  \r\nlet formattedNum = num.toPrecision(4);  \r\nconsole.log(formattedNum); // \"123.5\"\r\n```\r\n\r\n**2\\. String**: represents a sequence of characters, enclosed in single or double quotes.\r\n\r\n```js\r\nlet name = \"John Doe\";  \r\n// length  \r\nlet str = \"Hello, world!\";  \r\nconsole.log(str.length); // 13  \r\n// toUpperCase(), toLowerCase()  \r\nlet str = \"Hello, world!\";  \r\nconsole.log(str.toUpperCase()); // \"HELLO, WORLD!\"  \r\nconsole.log(str.toLowerCase()); // \"hello, world!\"  \r\n// trim()  \r\nlet str = \"  Hello, world!   \";  \r\nconsole.log(str.trim()); // Output: \"Hello, world!\"\r\n```\r\n\r\n**3\\. Boolean**: represents a logical value, either true or false.\r\n\r\n```js\r\nlet isStudent = true;  \r\n// ! (logical not)  \r\nconsole.log(!true); // false  \r\nconsole.log(!false); // true  \r\nconsole.log(!0); // true  \r\nconsole.log(!\"hello\"); // false  \r\nconsole.log(!null); // true\r\n```\r\n\r\n**4\\. Undefined**: represents a variable that has not been assigned a value yet.\r\n\r\n```js\r\nlet x;  \r\nconsole.log(x); // undefined\r\n```\r\n\r\n**5\\. Null**: represents a variable that has been explicitly assigned the value of null.\r\n\r\n```js\r\nlet x = null;  \r\nconsole.log(x); // null\r\n```\r\n\r\n**6\\. Symbol**: represents a unique identifier.\r\n\r\n```js\r\nlet firstName = Symbol(\"first name\");  \r\nlet person = {  \r\n  [firstName]: \"John\",  \r\n  lastName: \"Doe\",  \r\n  age: 30  \r\n};  \r\nconsole.log(person[firstName]); // John\r\n```\r\n\r\n**7\\. BigInt**: A numeric data type that represents integers larger than the maximum safe integer in JavaScript\r\n\r\n```js\r\nlet bigNumber = BigInt(Number.MAX_SAFE_INTEGER) + 1n;  \r\nconsole.log(bigNumber); // 9007199254740992n\r\n```\r\n\r\n8\\. In addition to these primitive data types, JavaScript has one non-primitive data type, which is the **Object**.\r\n\r\n```js\r\nlet person = {  \r\n  firstName: \"John\",  \r\n  lastName: \"Doe\",  \r\n  age: 30,  \r\n  address: {  \r\n    street: \"123 Main St\",  \r\n    city: \"Anytown\",  \r\n    state: \"CA\",  \r\n    zip: \"12345\"  \r\n  }  \r\n};  \r\nconsole.log(person.firstName); // John  \r\nconsole.log(person.address.city); // Anytown  \r\nperson.phone = \"555-1234\";  \r\nconsole.log(person); // { firstName: \"John\", lastName: \"Doe\", age: 30, address: { street: \"123 Main St\", city: \"Anytown\", state: \"CA\", zip: \"12345\" }, phone: \"555-1234\" }\r\n```\r\n\r\nIn JavaScript, arrays are a type of object. Arrays are a specialized kind of object that have a numeric index and a `**length**` property, and provide additional methods for working with ordered collections of data. Arrays can store any type of data as its elements, including objects themselves.\r\n\r\nArrays in JavaScript are created using the array literal syntax, which is enclosed in square brackets `**[]**`. Here's an example of an array:\r\n\r\n```js\r\nlet fruits = [\"apple\", \"banana\", \"orange\"];  \r\nconsole.log(fruits[0]); // apple  \r\nconsole.log(fruits.length); // 3  \r\nfruits.push(\"grape\");  \r\nconsole.log(fruits); // [\"apple\", \"banana\", \"orange\", \"grape\"]\r\n```\r\n\r\nSince JavaScript is a dynamically typed language, variables can hold values of any data type, and their data type can change during runtime.\r\n\r\nHowever, it’s worth noting that assigning a string to a variable that was previously holding a number is an example of implicit type conversion, as the variable’s data type has been changed without an explicit conversion using a function or operator. This can sometimes lead to unexpected behavior and bugs, so it’s important to use type conversions carefully and deliberately.\r\n\r\n```js\r\nlet x = 12;  \r\nx = \"hello\";  \r\nconsole.log(x) // hello\r\n```\r\n\r\nIt is important to understand the different data types in JavaScript and how type conversion works, as it can affect the behavior of your code."},{"id":"iterator-generator-and-closure-in-js","metadata":{"permalink":"/blog/iterator-generator-and-closure-in-js","editUrl":"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/20-iterator-generator-and-closure-in-js.md","source":"@site/blog/javascript/20-iterator-generator-and-closure-in-js.md","title":"Iterator, Generator and Closure in JS","description":"JavaScript is a versatile language that supports several powerful features that make it easier to write efficient, reusable, and modular code. In this blog post, we’ll take a closer look at three such features — iterators, generators, and closures.","date":"2024-05-16T10:39:22.000Z","tags":[{"label":"javascript","permalink":"/blog/tags/javascript"}],"readingTime":3.75,"hasTruncateMarker":true,"authors":[{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"}],"frontMatter":{"slug":"iterator-generator-and-closure-in-js","title":"Iterator, Generator and Closure in JS","authors":{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"},"tags":["javascript"]},"unlisted":false,"prevItem":{"title":"Datatypes in JS: Type Conversion","permalink":"/blog/datatypes-in-js-type-conversion"},"nextItem":{"title":"Proxy in JS","permalink":"/blog/proxy-in-js"}},"content":"JavaScript is a versatile language that supports several powerful features that make it easier to write efficient, reusable, and modular code. In this blog post, we’ll take a closer look at three such features — iterators, generators, and closures.\r\n<!-- truncate -->\r\n\r\nIterator\r\n========\r\n\r\nIterators are objects that allow you to traverse through a collection of data. In JavaScript, iterators are implemented using the **Symbol.iterator** method. This method returns an object with a **next()** method. The **next()** method returns an object with two properties — **value** and **done**. The **value** property is the next value in the collection and the **done** property is a boolean that indicates whether the end of the collection has been reached.\r\n\r\nHere is an example of how to use an iterator in JavaScript:\r\n\r\n```js\r\nconst arr = [1, 2, 3];  \r\nconst iterator = arr[Symbol.iterator]();  \r\nconsole.log(iterator.next()); // { value: 1, done: false }  \r\nconsole.log(iterator.next()); // { value: 2, done: false }  \r\nconsole.log(iterator.next()); // { value: 3, done: false }  \r\nconsole.log(iterator.next()); // { value: undefined, done: true }\r\n```\r\n\r\nere’s an example of how to implement an iterator for an array of values:\r\n\r\n```js\r\nlet arr = [1, 2, 3, 4];  \r\nlet myIterator = {  \r\n  [Symbol.iterator]() {  \r\n    let i = 0;  \r\n    return {  \r\n      next() {  \r\n        if (i < arr.length) {  \r\n          return { value: arr[i++], done: false };  \r\n        } else {  \r\n          return { value: undefined, done: true };  \r\n        }  \r\n      }  \r\n    };  \r\n  }  \r\n};  \r\nfor (let value of myIterator) {  \r\n  console.log(value);  \r\n}\r\n```\r\n\r\nGenerator\r\n=========\r\n\r\nGenerators are functions that allow you to define an iterative algorithm by writing a single function that can maintain its own state. In JavaScript, generators are defined using the **function\\\\*()** syntax. The **yield** keyword is used to indicate a pause in the generator, and the **next()** method is used to continue the generator from where it left off.\r\n\r\nHere is an example of how to use a generator in JavaScript:\r\n\r\n```js\r\nfunction* countFrom(n) {  \r\n  while (true) {  \r\n    yield n++;  \r\n  }  \r\n}  \r\nconst counter = countFrom(1);  \r\nconsole.log(counter.next()); // { value: 1, done: false }  \r\nconsole.log(counter.next()); // { value: 2, done: false }  \r\nconsole.log(counter.next()); // { value: 3, done: false }\r\n```\r\n\r\nGenerators are useful when you need to iterate through a large collection of data or when you need to maintain a specific state throughout the iteration process. They are also useful for creating custom iterable objects.\r\n\r\nClosure\r\n=======\r\n\r\nOne of the most common uses of closures is to create private variables and methods. By defining variables and functions inside another function, they are not accessible from the outside, but they can still be used by functions defined within the outer function.\r\n\r\nClosures are formed when a function is defined inside another function. The inner function has access to the outer function’s variables and parameters even after the outer function has returned. This allows for some interesting and powerful programming techniques.\r\n\r\nHere is an example of a closure in JavaScript:\r\n\r\n```js\r\nfunction outerFunction() {  \r\n  let outerVariable = \"I am outside!\";  \r\nfunction innerFunction() {  \r\n    console.log(outerVariable);  \r\n  }  \r\n  return innerFunction;  \r\n}  \r\nlet inner = outerFunction();  \r\ninner(); // \"I am outside!\"\r\n```\r\n\r\nThis is just one example of how closures can be used in JavaScript. They are a powerful tool for creating modular and encapsulated code.\r\n\r\nAnother common use of closures is to create factory functions. A factory function is a function that returns another function, and the returned function can be customized with parameters.\r\n\r\nHere is an example of a factory function that creates functions to add a given value to a number:\r\n\r\n```js\r\nfunction createAdder(value) {  \r\n  return function(number) {  \r\n    return number + value;  \r\n  }  \r\n}  \r\nlet add5 = createAdder(5);  \r\nlet add10 = createAdder(10);  \r\nconsole.log(add5(2)); // 7  \r\nconsole.log(add10(2)); // 12\r\n```\r\n\r\nClosures can also be used to create iterators. An iterator is an object that returns a sequence of values, typically used in a loop.\r\n\r\nHere is an example of an iterator created using a closure:\r\n\r\n```js\r\nfunction createCounter() {  \r\n  let count = 0;  \r\nreturn function() {  \r\n    count++;  \r\n    return count;  \r\n  }  \r\n}  \r\nlet counter = createCounter();  \r\nconsole.log(counter()); // Output: 1  \r\nconsole.log(counter()); // Output: 2  \r\nconsole.log(counter()); // Output: 3\r\n```\r\n\r\nWhen `counter` is called, it returns a new value each time, starting with 1. This allows for easy iteration over a sequence of numbers without the need for a traditional loop.\r\n\r\nIn conclusion, closures are a powerful tool in JavaScript for creating modular and encapsulated code. They allow for private variables and methods, factory functions, and iterators. Understanding closures is an important part of learning advanced JavaScript programming techniques."},{"id":"proxy-in-js","metadata":{"permalink":"/blog/proxy-in-js","editUrl":"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/21-proxy-in-js.md","source":"@site/blog/javascript/21-proxy-in-js.md","title":"Proxy in JS","description":"JavaScript Proxy is a powerful feature that was introduced in ECMAScript 6 (ES6) that allows us to intercept and customize operations performed on objects. It allows us to define custom behavior for fundamental operations like object property access, assignment, and deletion. In this blog post, we’ll dive deeper into the concept of proxies in JavaScript.","date":"2024-05-16T10:39:22.000Z","tags":[{"label":"javascript","permalink":"/blog/tags/javascript"}],"readingTime":4.1,"hasTruncateMarker":true,"authors":[{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"}],"frontMatter":{"slug":"proxy-in-js","title":"Proxy in JS","authors":{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"},"tags":["javascript"]},"unlisted":false,"prevItem":{"title":"Iterator, Generator and Closure in JS","permalink":"/blog/iterator-generator-and-closure-in-js"},"nextItem":{"title":"Module in JS: Import, Export","permalink":"/blog/module-in-js-import-export"}},"content":"JavaScript Proxy is a powerful feature that was introduced in ECMAScript 6 (ES6) that allows us to intercept and customize operations performed on objects. It allows us to define custom behavior for fundamental operations like object property access, assignment, and deletion. In this blog post, we’ll dive deeper into the concept of proxies in JavaScript.\r\n<!-- truncate -->\r\n\r\nWhat is a Proxy?\r\n================\r\n\r\nA proxy is an object that wraps an existing object and intercepts operations performed on the wrapped object. It acts as a middleman between the code and the original object, allowing us to modify its behavior without modifying the object itself.\r\n\r\nCreating a Proxy\r\n================\r\n\r\nTo create a Proxy, you need to use the `Proxy` constructor. The `Proxy` constructor takes two arguments: the target object and a handler object. The target object is the object that you want to wrap with the Proxy, and the handler object is an object that defines the behavior of the Proxy.\r\n\r\n```js\r\nlet target = {};  \r\nlet handler = {};  \r\nlet proxy = new Proxy(target, handler);\r\n```\r\n\r\nHandler object\r\n==============\r\n\r\nThe handler object is used to define the behavior of the Proxy. It is an object that contains one or more methods called traps. The traps are called when certain operations are performed on the Proxy.\r\n\r\nTrap methods\r\n============\r\n\r\nThe following are the available trap methods:\r\n\r\n*   `get(target, property, receiver)`: This trap is called when a property of the Proxy is accessed.\r\n*   `set(target, property, value, receiver)`: This trap is called when a property of the Proxy is set.\r\n*   `apply(target, thisArg, argumentsList)`: This trap is called when the Proxy is called as a function.\r\n*   `construct(target, argumentsList, newTarget)`: This trap is called when the Proxy is used with the `new` keyword.\r\n*   `has(target, property)`: This trap is called when the `in` operator is used on the Proxy.\r\n*   `deleteProperty(target, property)`: This trap is called when a property of the Proxy is deleted.\r\n*   `getOwnPropertyDescriptor(target, property)`: This trap is called when the `Object.getOwnPropertyDescriptor()` method is called on the Proxy.\r\n*   `defineProperty(target, property, descriptor)`: This trap is called when the `Object.defineProperty()` method is called on the Proxy.\r\n*   `getPrototypeOf(target)`: This trap is called when the `Object.getPrototypeOf()` method is called on the Proxy.\r\n*   `setPrototypeOf(target, prototype)`: This trap is called when the `Object.setPrototypeOf()` method is called on the Proxy.\r\n\r\nExamples\r\n========\r\n\r\nLet’s take an example to understand how to create a proxy:\r\n\r\n```js\r\nlet target = {  \r\n    name: \"John\",  \r\n    age: 30  \r\n};  \r\nlet handler = {  \r\n    get: function(target, prop, receiver) {  \r\n        console.log(`Getting ${prop}`);  \r\n        return target[prop];  \r\n    },  \r\n    set: function(target, prop, value) {  \r\n        console.log(`Setting ${prop} to ${value}`);  \r\n        target[prop] = value;  \r\n    }  \r\n};  \r\nlet proxy = new Proxy(target, handler);  \r\nconsole.log(proxy.name); // Getting name, John  \r\nproxy.age = 40; // Setting age to 40  \r\nconsole.log(proxy.age); // Getting age, 40\r\n```\r\n\r\nAnother example where the Proxy is used for validation:\r\n\r\n```js\r\nlet user = {  \r\n    name: \"\",  \r\n    age: 0  \r\n};  \r\nlet handler = {  \r\n    set: function(target, prop, value) {  \r\n        if (prop === \"age\" && (!Number.isInteger(value) || value < 0)) {  \r\n            throw new TypeError(\"Age must be a positive integer\");  \r\n        }  \r\n        target[prop] = value;  \r\n    }  \r\n};  \r\nlet proxy = new Proxy(user, handler);  \r\nproxy.name = \"John\";  \r\nproxy.age = 30;  \r\nconsole.log(proxy); // {name: \"John\", age: 30}  \r\nproxy.age = -1; // Throws TypeError: Age must be a positive integer\r\n```\r\n\r\nCommon use cases of Proxies\r\n===========================\r\n\r\nValidation\r\n==========\r\n\r\nOne of the most common use cases for proxies is input validation. Proxies can be used to define rules for valid data types and formats for object properties, and any attempts to set properties that violate these rules can be blocked or thrown an error.\r\n\r\n```js\r\nlet target = {};  \r\nlet handler = {  \r\n    set: function(target, property, value, receiver) {  \r\n        if (typeof value !== 'string') {  \r\n            throw new Error('Only string values are allowed');  \r\n        }  \r\n        target[property] = value;  \r\n        return true;  \r\n    }  \r\n};  \r\nlet proxy = new Proxy(target, handler);  \r\nproxy.name = \"John\"; // Allowed  \r\nproxy.age = 30; // Throws an error\r\n```\r\n\r\nPerformance optimization\r\n========================\r\n\r\nAnother common use case for proxies is performance optimization. For example, suppose you have a large object that is frequently accessed, and you want to cache its properties to improve performance. You can use a proxy to intercept property access and cache the values to avoid repeated access to the object.\r\n\r\n```js\r\nlet target = { /* Large object */ };  \r\nlet cache = {};  \r\nlet handler = {  \r\n    get: function(target, property, receiver) {  \r\n        if (!(property in cache)) {  \r\n            cache[property] = target[property];  \r\n        }  \r\n        return cache[property];  \r\n    }  \r\n};  \r\nlet proxy = new Proxy(target, handler);  \r\nconsole.log(proxy.property1); // The value is cached  \r\nconsole.log(proxy.property2); // The value is cached\r\n```\r\n\r\nProxies are a powerful feature in JavaScript that allows you to intercept and customize certain operations that are performed on another object. They provide a way to implement custom behavior for fundamental language operations that is not possible with normal JavaScript objects. Proxies can be used for a variety of purposes such as validation, logging, and caching."},{"id":"module-in-js-import-export","metadata":{"permalink":"/blog/module-in-js-import-export","editUrl":"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/22-module-in-js-import-export.md","source":"@site/blog/javascript/22-module-in-js-import-export.md","title":"Module in JS: Import, Export","description":"JavaScript modules are a way of organizing code into reusable, self-contained components that can be easily imported and exported between different parts of an application. They provide a mechanism for encapsulating code and avoiding naming collisions, making it easier to build and maintain large-scale applications. In this blog post, we’ll dive deeper into the concept of modules in JavaScript.","date":"2024-05-16T10:39:22.000Z","tags":[{"label":"javascript","permalink":"/blog/tags/javascript"}],"readingTime":4.04,"hasTruncateMarker":true,"authors":[{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"}],"frontMatter":{"slug":"module-in-js-import-export","title":"Module in JS: Import, Export","authors":{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"},"tags":["javascript"]},"unlisted":false,"prevItem":{"title":"Proxy in JS","permalink":"/blog/proxy-in-js"},"nextItem":{"title":"Browser Environment in JS","permalink":"/blog/browser-environment-in-js"}},"content":"JavaScript modules are a way of organizing code into reusable, self-contained components that can be easily imported and exported between different parts of an application. They provide a mechanism for encapsulating code and avoiding naming collisions, making it easier to build and maintain large-scale applications. In this blog post, we’ll dive deeper into the concept of modules in JavaScript.\r\n<!-- truncate -->\r\n\r\nThe module system in JavaScript\r\n===============================\r\n\r\nJavaScript modules were introduced in ECMAScript 6 (ES6) and are now a standard feature of modern JavaScript. The module system in JavaScript allows us to define modules, which are self-contained units of code that can be imported and used in other parts of an application. Each module has its own private scope, which means that variables, functions, and classes defined in a module are not accessible from outside the module unless they are explicitly exported.\r\n\r\nModules can be defined in two ways: using the `**import**` and `**export**` keywords or using the `**CommonJS**` module system.\r\n\r\nUsing `import` and `export`\r\n===========================\r\n\r\nExporting a Module\r\n------------------\r\n\r\nTo make a variable, function or object available to other files, we need to export it. We can use the `export` keyword to do so. For example,\r\n\r\n```js\r\n// greet.js  \r\nexport function sayHello(name) {  \r\n  console.log(`Hello, ${name}!`);  \r\n}  \r\nexport let message = \"Welcome to our website\";\r\n```\r\n\r\nImporting a Module\r\n------------------\r\n\r\nTo use the exported variable, function or object in another file, we need to import it. We can use the `import` keyword to do so. For example,\r\n\r\n```js\r\n// main.js  \r\nimport { sayHello, message } from './greet.js';  \r\nsayHello('Lily'); // Output: Hello, Lily!  \r\nconsole.log(message); // Output: Welcome to our website\r\n```\r\n\r\nWe can also import everything from a module using the `*` character. For example,\r\n\r\n```js\r\n// main.js  \r\nimport * as greetings from './greet.js';  \r\ngreetings.sayHello('Lily'); // Output: Hello, Lily!  \r\nconsole.log(greetings.message); // Output: Welcome to our website\r\n```\r\n\r\nDynamic Import\r\n--------------\r\n\r\nDynamic import is a new feature in JavaScript that allows us to load modules on-demand or asynchronously. This can be useful when we have a large application with many modules, and we don’t want to load all of them at once. Instead, we can load only the modules that are needed at a particular time. To use dynamic import, we can use the `import()` function. For example,\r\n\r\n```js\r\n// main.js  \r\nimport('./greet.js')  \r\n  .then(module => {  \r\n    module.sayHello('Lily'); // Output: Hello, Lily!  \r\n    console.log(module.message); // Output: Welcome to our website  \r\n  })  \r\n  .catch(err => {  \r\n    console.log('Failed to load module:', err);  \r\n  });\r\n```\r\n\r\nDefault Export\r\n--------------\r\n\r\nWe can also have a default export in a module. We use the `export default` syntax to do so. For example,\r\n\r\n```js\r\n// greet.js  \r\nexport default function(name) {  \r\n  console.log(`Hello, ${name}!`);  \r\n}\r\n```\r\n\r\nIn this case, we don’t need to use curly braces while importing the default export. For example,\r\n\r\n```js\r\n// main.js  \r\nimport sayHello from './greet.js';  \r\nsayHello('Lily'); // Output: Hello, Lily!\r\n```\r\n\r\nUsing `CommonJS`\r\n================\r\n\r\nThe `**CommonJS**` module system is an older, but still widely used module system in Node.js. It allows us to define modules using the `**module.exports**` and `**require**` keywords. With `**module.exports**`, we can export variables, functions, and classes from our module. With `**require**`, we can import variables, functions, and classes from other modules.\r\n\r\nHere’s an example of how to define and use modules using the `**CommonJS**` module system:\r\n\r\n```js\r\n// Math.js  \r\nconst add = (a, b) => a + b;  \r\nconst subtract = (a, b) => a - b;  \r\nmodule.exports = { add, subtract };\r\n```\r\n\r\n```js\r\n// App.js  \r\nconst { add, subtract } = require('./Math.js');  \r\nconsole.log(add(2, 3)); // Output: 5  \r\nconsole.log(subtract(5, 2)); // Output: 3\r\n```\r\n\r\nAdvantages of using modules\r\n===========================\r\n\r\nUsing modules in JavaScript has several advantages, including:\r\n\r\nEncapsulation\r\n-------------\r\n\r\nModules provide a way of encapsulating code, which means that variables, functions, and classes defined in a module are not accessible from outside the module unless they are explicitly exported. This helps to prevent naming collisions and makes it easier to build and maintain large-scale applications.\r\n\r\nReusability\r\n-----------\r\n\r\nModules can be easily imported and exported between different parts of an application, making it easy to reuse code across multiple files and projects. This can save a lot of time and effort when building complex applications.\r\n\r\nDependency management\r\n---------------------\r\n\r\nModules can be used to manage dependencies between different parts of an application. By importing only the specific functions or classes that are needed from a module, we can reduce the amount of code that needs to be loaded, which can improve application performance.\r\n\r\nIn conclusion, JavaScript modules provide a way of organizing code into reusable, self-contained components that can be easily imported and exported between different parts of an application. They provide a mechanism for encapsulating code and avoiding naming collisions, making it easier to build and maintain large-scale applications. By using modules, we can improve the reusability, encapsulation, and dependency management of our code, which can lead to more efficient and maintainable applications."},{"id":"browser-environment-in-js","metadata":{"permalink":"/blog/browser-environment-in-js","editUrl":"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/23-browser-environment-in-js.md","source":"@site/blog/javascript/23-browser-environment-in-js.md","title":"Browser Environment in JS","description":"JavaScript is a programming language that is widely used for developing web applications. It is a client-side scripting language that runs in the browser. In this document, we will discuss the browser environment in JS.","date":"2024-05-16T10:39:22.000Z","tags":[{"label":"javascript","permalink":"/blog/tags/javascript"}],"readingTime":8.67,"hasTruncateMarker":true,"authors":[{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"}],"frontMatter":{"slug":"browser-environment-in-js","title":"Browser Environment in JS","authors":{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"},"tags":["javascript"]},"unlisted":false,"prevItem":{"title":"Module in JS: Import, Export","permalink":"/blog/module-in-js-import-export"},"nextItem":{"title":"Browser Events in JS","permalink":"/blog/browser-events-in-js"}},"content":"JavaScript is a programming language that is widely used for developing web applications. It is a client-side scripting language that runs in the browser. In this document, we will discuss the browser environment in JS.\r\n<!-- truncate -->\r\n\r\n**What is Browser Environment?**\r\n\r\nBrowser environment refers to the environment in which the JavaScript code runs in a web browser. It is different from the server-side environment because the code is executed on the client-side. The browser environment provides a set of objects and APIs that can be used to manipulate the DOM (Document Object Model), handle events, and interact with the user.\r\n\r\n**How JavaScript Runs in Web Browsers?**\r\n\r\nWhen a web page is loaded in a browser, the browser creates a Document Object Model (DOM) for the page. The DOM is a hierarchical representation of the HTML elements in the page. Each HTML element is represented as a node in the DOM tree, and each node has properties and methods that can be accessed and manipulated using JavaScript.\r\n\r\nJavaScript is executed by the browser’s JavaScript engine, which is responsible for parsing and executing the JavaScript code in the page. The JavaScript engine runs in a separate thread from the browser’s rendering engine, which is responsible for rendering the HTML and CSS in the page.\r\n\r\nBOM (Browser Object Model)\r\n==========================\r\n\r\nThe Browser Object Model (BOM) is a set of JavaScript objects that provide an interface for interacting with the browser window. The BOM is not a part of the JavaScript language itself, but it is implemented by all major web browsers.\r\n\r\nHere are some of the most commonly used objects in the BOM:\r\n\r\n*   `**window**`: The `**window**` object represents the browser window and provides access to the browser's methods and properties.\r\n*   `**document**`: The `**document**` object represents the current web page and provides access to the page's DOM.\r\n*   `**location**`: The `**location**` object represents the current URL of the web page and provides methods for navigating to other URLs.\r\n*   `**navigator**`: The `**navigator**` object provides information about the browser and the user's system.\r\n*   `**screen**`: The `**screen**` object provides information about the user's screen size and resolution.\r\n\r\nHere’s an example of how to use the `**window**` object to display an alert message:\r\n\r\n```js\r\nwindow.alert('Hello, world!');\r\n```\r\n\r\nDOM (Document Object Model)\r\n===========================\r\n\r\nThe Document Object Model (DOM) is a hierarchical representation of the HTML elements in a web page. Each HTML element is represented as a node in the DOM tree, and each node has properties and methods that can be accessed and manipulated using JavaScript.\r\n\r\nHere’s an example of how to manipulate the DOM using JavaScript:\r\n\r\n```js\r\n// Get the element with the ID \"myElement\"  \r\nvar element = document.getElementById(\"myElement\");  \r\n// Change the text of the element  \r\nelement.innerText = \"Hello, World!\";\r\n```\r\n\r\nDOM Tree\r\n========\r\n\r\nThe DOM tree is a hierarchical structure that represents the HTML document. It consists of elements, attributes, and text nodes. JavaScript can traverse and manipulate the DOM tree using a variety of methods and properties. Developers can use these methods and properties to create dynamic web applications that respond to user input and interaction.\r\n\r\nThe DOM (Document Object Model) tree is a hierarchical representation of the HTML or XML document, where each element in the document is represented by a node in the tree. The DOM tree is used by web browsers to render the web pages and allows developers to access and manipulate the content and structure of the web page using JavaScript. Let’s take a look at an example of the DOM tree.\r\n\r\nConsider the following HTML code:\r\n\r\n```js\r\n<!DOCTYPE html>  \r\n<html>  \r\n  <head>  \r\n    <title>DOM Tree Example</title>  \r\n  </head>  \r\n  <body>  \r\n    <div id=\"container\">  \r\n      <h1>Welcome to my website</h1>  \r\n      <p>This is a paragraph</p>  \r\n      <ul>  \r\n        <li>Item 1</li>  \r\n        <li>Item 2</li>  \r\n        <li>Item 3</li>  \r\n      </ul>  \r\n    </div>  \r\n  </body>  \r\n</html>\r\n```\r\n\r\nStructure of DOM\r\n================\r\n\r\nThe DOM tree is a hierarchical structure that starts with the `**document**` node at the top. The `**document**` node represents the entire HTML document and is the parent node of all other nodes in the tree.\r\n\r\nThe `**document**` node has one child node, the `**html**` node. The `**html**` node represents the HTML content of the web page and is the parent node of all other nodes in the tree.\r\n\r\nThe `**html**` node has two child nodes, the `**head**` node and the `**body**` node. The `**head**` node represents the head section of the web page and contains metadata such as the page title and links to CSS stylesheets. The `**body**` node represents the body section of the web page and contains the visible content of the page.\r\n\r\nThe `**head**` and `**body**` nodes can have child nodes, which represent the HTML elements in the web page. Each HTML element is represented as a node in the DOM tree, and each node has properties and methods that can be accessed and manipulated using JavaScript.\r\n\r\nThe corresponding DOM tree for this HTML code would look like this:\r\n\r\n```js\r\nhtml  \r\n├── head  \r\n│   └── title  \r\n│       └── \"DOM Tree Example\"  \r\n└── body  \r\n    └── div#container  \r\n        ├── h1  \r\n        │   └── \"Welcome to my website\"  \r\n        ├── p  \r\n        │   └── \"This is a paragraph\"  \r\n        └── ul  \r\n            ├── li  \r\n            │   └── \"Item 1\"  \r\n            ├── li  \r\n            │   └── \"Item 2\"  \r\n            └── li  \r\n                └── \"Item 3\"\r\n```\r\n\r\nSelecting DOM Elements in JS\r\n============================\r\n\r\nJavaScript is a powerful scripting language that can be used to manipulate the Document Object Model (DOM) of a webpage. One of the key tasks in working with the DOM is selecting specific elements from the HTML document.\r\n\r\n**Selecting Elements by ID**\r\n\r\nThe most common way to select an element from the DOM is by its ID. To select an element by ID, use the `getElementById` method. This method takes the ID of the element as a parameter and returns the element object.\r\n\r\n```js\r\nlet element = document.getElementById(\"myElement\");\r\n```\r\n\r\n**Selecting Elements by Class Name**\r\n\r\nYou can also select elements by their class name using the `getElementsByClassName` method. This method returns an array-like object containing all the elements that have the specified class name.\r\n\r\n```js\r\nlet elements = document.getElementsByClassName(\"myClass\");\r\n```\r\n\r\n**Selecting Elements by Tag Name**\r\n\r\nAnother way to select elements from the DOM is by their tag name. The `getElementsByTagName` method returns an array-like object containing all the elements with the specified tag name.\r\n\r\n```js\r\nlet elements = document.getElementsByTagName(\"div\");\r\n```\r\n\r\n**Selecting Elements with CSS Selectors**\r\n\r\nCSS selectors can also be used to select elements from the DOM. The `querySelector` and `querySelectorAll` methods can be used to select elements using CSS selectors.\r\n\r\n```js\r\nlet element = document.querySelector(\"#myElement .myClass\");  \r\nlet elements = document.querySelectorAll(\"div.myClass\");\r\n```\r\n\r\nSelecting DOM elements in JS is a fundamental task that every web developer should know. With the above examples, you can now easily select any element from the DOM using JS.\r\n\r\nTypes of Nodes in the DOM Tree\r\n==============================\r\n\r\nHere are the main types of nodes in the DOM:\r\n\r\n1.  **Element Node:** represents an HTML element, such as `**<div>**`, `**<p>**`, or `**<img>**`. Element nodes have properties that correspond to their attributes, such as `**id**`, `**class**`, `**src**`, and so on.\r\n\r\n```js\r\n// Create a new div element  \r\nconst myDiv = document.createElement('div');  \r\n// Set attributes for the div element  \r\nmyDiv.setAttribute('id', 'myDiv');  \r\nmyDiv.setAttribute('class', 'myClass');  \r\n// Add text content to the div element  \r\nmyDiv.textContent = 'This is a div element.';  \r\n// Append the div element to the document body  \r\ndocument.body.appendChild(myDiv);\r\n```\r\n\r\n**2\\. Text Node**: represents the text content of an HTML element. Text nodes are usually the children of element nodes.\r\n\r\n```js\r\n// Create a new text node  \r\nconst myText = document.createTextNode('This is a text node.');  \r\n// Append the text node to an existing element  \r\nconst myDiv = document.getElementById('myDiv');  \r\nmyDiv.appendChild(myText);\r\n```\r\n\r\n**3\\. Attribute Node**: represents an attribute of an HTML element, such as `**id**`, `**class**`, or `**src**`. Attribute nodes are part of element nodes.\r\n\r\n```js\r\n// Get an existing element and its attributes  \r\nconst myDiv = document.getElementById('myDiv');  \r\nconst myId = myDiv.getAttribute('id');  \r\nconst myClass = myDiv.getAttribute('class');  \r\n// Set a new attribute value  \r\nmyDiv.setAttribute('class', 'newClass');\r\n```\r\n\r\n**4\\. Comment Node**: represents a comment in an HTML document. Comment nodes can be used to add notes or reminders to the code without affecting the rendering of the page.\r\n\r\n```js\r\n// Create a new comment node  \r\nconst myComment = document.createComment('This is a comment.');  \r\n// Append the comment node to an existing element  \r\nconst myDiv = document.getElementById('myDiv');  \r\nmyDiv.appendChild(myComment);\r\n```\r\n\r\n**5\\. Document Node:** represents the entire HTML document. It is the root of the tree structure.\r\n\r\n```js\r\n// Get the document object  \r\nconst myDoc = document;  \r\n// Output the name and public ID of the document type  \r\nconsole.log(myDocType.name); // Outputs \"html\"  \r\nconsole.log(myDocType.publicId); // Outputs the public ID of the document type\r\n```\r\n\r\n**6\\. Document Type Node**: represents the document type declaration, which specifies the version of HTML or XML that the document conforms to.\r\n\r\n```js\r\n// Get the document type declaration  \r\nconst myDocType = document.doctype;  \r\n// Output the name and public ID of the document type  \r\nconsole.log(myDocType.name); // Outputs \"html\"  \r\nconsole.log(myDocType.publicId); // Outputs the public ID of the document type\r\n```\r\n\r\n**7\\. Document Fragment Node**: represents a container for a group of nodes. Document fragment nodes can be used to create and manipulate groups of nodes before adding them to the document.\r\n\r\n```js\r\n// Create a new document fragment  \r\nconst myFrag = document.createDocumentFragment();  \r\n// Create new elements and append them to the fragment  \r\nconst myDiv1 = document.createElement('div');  \r\nmyDiv1.textContent = 'This is div 1.';  \r\nmyFrag.appendChild(myDiv1);  \r\nconst myDiv2 = document.createElement('div');  \r\nmyDiv2.textContent = 'This is div 2.';  \r\nmyFrag.appendChild(myDiv2);  \r\n// Append the fragment to an existing element  \r\nconst myContainer = document.getElementById('myContainer');  \r\nmyContainer.appendChild(myFrag);\r\n```\r\n\r\nStyle and Class\r\n===============\r\n\r\nIn JavaScript, you can manipulate the style and classes of HTML elements in the DOM using the `**style**` and `**classList**` properties, respectively.\r\n\r\n```js\r\n// Get a reference to the HTML element  \r\nconst myElement = document.getElementById('myElement');  \r\n// Change the background color of the element  \r\nmyElement.style.backgroundColor = 'red';  \r\n// Set multiple CSS styles on the element  \r\nmyElement.style.cssText = 'background-color: red; color: white; font-size: 16px;';  \r\n// Get the value of a specific CSS style  \r\nconst backgroundColor = myElement.style.backgroundColor;  \r\n// Add a CSS class to the element  \r\nmyElement.classList.add('myClass');  \r\n// Remove a CSS class from the element  \r\nmyElement.classList.remove('myClass');  \r\n// Check if the element has the CSS class  \r\nif (myElement.classList.contains('myClass')) {  \r\n  // Do something  \r\n}  \r\n// Toggle the CSS class on the element  \r\nmyElement.classList.toggle('myClass');\r\n```\r\n\r\nIn conclusion, the browser environment in JS provides a powerful set of tools that can be used to create dynamic and interactive web applications. Understanding the browser environment is essential for any web developer who wants to create engaging and responsive user experiences."},{"id":"browser-events-in-js","metadata":{"permalink":"/blog/browser-events-in-js","editUrl":"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/24-browser-events-in-js.md","source":"@site/blog/javascript/24-browser-events-in-js.md","title":"Browser Events in JS","description":"In JavaScript, events are actions or occurrences that happen in the browser, such as a user clicking on a button or a page finishing loading. JavaScript can listen to these events and execute code in response.","date":"2024-05-16T10:39:22.000Z","tags":[{"label":"javascript","permalink":"/blog/tags/javascript"}],"readingTime":5.695,"hasTruncateMarker":true,"authors":[{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"}],"frontMatter":{"slug":"browser-events-in-js","title":"Browser Events in JS","authors":{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"},"tags":["javascript"]},"unlisted":false,"prevItem":{"title":"Browser Environment in JS","permalink":"/blog/browser-environment-in-js"},"nextItem":{"title":"Advance Concepts of Events in JS: Bubbling, Capturing","permalink":"/blog/advance-concepts-of-events-in-js-bubbling-capturing"}},"content":"In JavaScript, events are actions or occurrences that happen in the browser, such as a user clicking on a button or a page finishing loading. JavaScript can listen to these events and execute code in response.\r\n<!-- truncate -->\r\n\r\nThere are many types of events in JavaScript, including:\r\n\r\n*   Mouse events: click, hover, mouseover, etc.\r\n*   Keyboard events: keypress, keydown, keyup\r\n*   Form events: submit, change, reset\r\n*   Window events: load, resize, scroll\r\n\r\n`addEventListener` and `removeEventListener` in JS\r\n==================================================\r\n\r\n`**addEventListener**` and `**removeEventListener**` are two methods in JavaScript that allow us to add and remove event listeners to HTML elements.\r\n\r\nAn event listener is a function that gets executed when an event occurs on an HTML element, like a click or a key press. When you add an event listener to an element using `**addEventListener**`, you specify which event to listen for and which function should be executed when that event occurs.\r\n\r\n`**addEventListener**` takes two arguments:\r\n\r\n1.  The type of the event to listen for (e.g. `**click**`, `**mouseover**`, `**keydown**`)\r\n2.  The function that should be executed when the event occurs\r\n\r\n`**removeEventListener**` is used to remove an event listener from an element. It takes the same two arguments as `**addEventListener**`: the type of the event to remove and the function that should no longer be executed when that event occurs.\r\n\r\nMouse Events in JS\r\n==================\r\n\r\nIn JavaScript, you can handle mouse events using event listeners. Mouse events occur when the user interacts with the mouse, such as clicking a button, moving the cursor over an element, or scrolling the page. There are several mouse events that you can handle in JavaScript, such as click, double click, mouse over, mouse out, mouse down, and mouse up.\r\n\r\nAdding Mouse Event Listeners\r\n============================\r\n\r\nTo add a mouse event listener to an element, you can use the `**addEventListener**` method. This method takes two parameters: the type of event to listen for (such as \"click\" or \"mouseover\"), and a callback function to be executed when the event occurs. Here's an example:\r\n\r\n```js\r\n// Get a reference to an element in the document  \r\nconst button = document.querySelector('#my-button');  \r\n// Add a click event listener to the element  \r\nbutton.addEventListener('click', function() {  \r\n  console.log('The button was clicked.');  \r\n});\r\n```\r\n\r\nIn this example, we add a click event listener to a button element. When the button is clicked, the callback function logs a message to the console.\r\n\r\nMouse Event Types\r\n=================\r\n\r\nHere are some of the most commonly used mouse events in JavaScript:\r\n\r\n*   `**click**`: Occurs when the mouse button is clicked on an element.\r\n*   `**dblclick**`: Occurs when the mouse button is double-clicked on an element.\r\n*   `**mouseover**`: Occurs when the mouse pointer is moved over an element.\r\n*   `**mouseout**`: Occurs when the mouse pointer leaves an element.\r\n*   `**mousedown**`: Occurs when the mouse button is pressed down on an element.\r\n*   `**mouseup**`: Occurs when the mouse button is released on an element.\r\n*   `**mousemove**`: Occurs when the mouse pointer is moved over an element.\r\n\r\nYou can add event listeners for these events using the `**addEventListener**` method, just as we did in the previous example.\r\n\r\nEvent Object\r\n============\r\n\r\nWhen a mouse event occurs, an event object is created that contains information about the event, such as the position of the mouse pointer and the element that triggered the event. This event object is passed as an argument to the event listener function.\r\n\r\nHere’s an example of how you can access the event object in a mouse event listener:\r\n\r\n```js\r\n// Get a reference to an element in the document  \r\nconst element = document.querySelector('#my-element');  \r\n// Add a mouseover event listener to the element  \r\nelement.addEventListener('mouseover', function(event) {  \r\n  // Log the event object to the console  \r\n  console.log(event);  \r\n});\r\n```\r\n\r\nIn JavaScript, when you attach an event listener to an element, the event object that is passed to the event handler function has two important properties: `**currentTarget**` and `**target**`.\r\n\r\nThe `**currentTarget**` property refers to the element on which the event listener was attached. This property will always refer to the same element, regardless of which child element actually triggered the event.\r\n\r\nThe `**target**` property, on the other hand, refers to the element that actually triggered the event. This property will be different depending on which child element was clicked or interacted with.\r\n\r\n```js\r\n<div class=\"parent\">  \r\n  <button class=\"child\">Click me!</button>  \r\n</div>  \r\n<script>  \r\n  const parent = document.querySelector('.parent');  \r\n  parent.addEventListener('click', function(event) {  \r\n    console.log('currentTarget:', event.currentTarget); // <div class=\"parent\">...</div>  \r\n    console.log('target:', event.target); // <button class=\"child\">Click me!</button>  \r\n  });  \r\n</script>\r\n```\r\n\r\nKeyboard Events in JS\r\n=====================\r\n\r\nKeyboard events in JavaScript are events that are triggered when a user interacts with their keyboard. These events allow us to respond to the user’s input and provide interactivity to our web applications.\r\n\r\nThere are three types of keyboard events in JavaScript: `**keydown**`, `**keyup**`, and `**keypress**`. Each event is triggered at a different point during the user's interaction with the keyboard.\r\n\r\n`keydown` Event\r\n===============\r\n\r\nThe `**keydown**` event is triggered when a key is pressed down. This event occurs before the character is inputted into the document. It is useful for detecting when the user first starts typing a character. The `**keydown**` event is also useful for detecting non-character keys such as the arrow keys, backspace, and delete keys.\r\n\r\nHere is an example of adding a `**keydown**` event listener to an input element:\r\n\r\n```js\r\nconst input = document.querySelector('input');  \r\ninput.addEventListener('keydown', function(event) {  \r\n  console.log('Key pressed:', event.key);  \r\n});\r\n```\r\n\r\n`keyup` Event\r\n=============\r\n\r\nThe `**keyup**` event is triggered when a key is released. This event occurs after the character is inputted into the document. It is useful for detecting when the user has finished typing a character. The `**keyup**` event is also useful for detecting non-character keys such as the arrow keys, backspace, and delete keys.\r\n\r\nHere is an example of adding a `**keyup**` event listener to an input element:\r\n\r\n```js\r\nconst input = document.querySelector('input');  \r\ninput.addEventListener('keyup', function(event) {  \r\n  console.log('Key released:', event.key);  \r\n});\r\n```\r\n\r\n`keypress` Event\r\n================\r\n\r\nThe `**keypress**` event is triggered when a key is pressed down and then released. This event occurs after the character is inputted into the document. It is useful for detecting when the user types a printable character such as a letter, number, or symbol.\r\n\r\nHere is an example of adding a `**keypress**` event listener to an input element:\r\n\r\n```js\r\nconst input = document.querySelector('input');  \r\ninput.addEventListener('keypress', function(event) {  \r\n  console.log('Key pressed and released:', event.key);  \r\n});\r\n```\r\n\r\nPreventing Default Behavior\r\n===========================\r\n\r\nIn some cases, we may want to prevent the default behavior of a keyboard event. For example, we may want to prevent the Enter key from submitting a form or the Tab key from changing the focus to the next element. To do this, we can call the `**preventDefault**` method on the `**event**` object passed to the\r\n\r\nIn conclusion, how to handle browser events in JavaScript, including mouse and keyboard events are important concept when working with browsers. `addEventListener` and `removeEventListener` are methods to perform specific action on any browser event."},{"id":"advance-concepts-of-events-in-js-bubbling-capturing","metadata":{"permalink":"/blog/advance-concepts-of-events-in-js-bubbling-capturing","editUrl":"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/25-advance-concepts-of-events-in-js-bubbling-capturing.md","source":"@site/blog/javascript/25-advance-concepts-of-events-in-js-bubbling-capturing.md","title":"Advance Concepts of Events in JS: Bubbling, Capturing","description":"Events in JavaScript are a fundamental part of building interactive web applications. They allow us to respond to user actions, such as clicking a button or scrolling the page. In addition to handling events, it is important to understand the concepts of event propagation: bubbling and capturing. In this article, we will dive into these concepts and learn how they can be used to handle events in more advanced ways.","date":"2024-05-16T10:39:22.000Z","tags":[{"label":"javascript","permalink":"/blog/tags/javascript"}],"readingTime":5.275,"hasTruncateMarker":true,"authors":[{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"}],"frontMatter":{"slug":"advance-concepts-of-events-in-js-bubbling-capturing","title":"Advance Concepts of Events in JS: Bubbling, Capturing","authors":{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"},"tags":["javascript"]},"unlisted":false,"prevItem":{"title":"Browser Events in JS","permalink":"/blog/browser-events-in-js"},"nextItem":{"title":"Handling Forms in JS","permalink":"/blog/handling-forms-in-js"}},"content":"Events in JavaScript are a fundamental part of building interactive web applications. They allow us to respond to user actions, such as clicking a button or scrolling the page. In addition to handling events, it is important to understand the concepts of event propagation: bubbling and capturing. In this article, we will dive into these concepts and learn how they can be used to handle events in more advanced ways.\r\n<!-- truncate -->\r\n\r\nEvent Propagation\r\n=================\r\n\r\nEvent propagation refers to the order in which events are handled as they “propagate” through the document object model (DOM) tree. The DOM tree is a hierarchical structure that represents the structure of an HTML document. When an event is triggered on an element, it can either be handled first by that element and then “bubble” up the DOM tree, or it can be handled first at the top of the tree and then “capture” down the tree to the element that triggered the event.\r\n\r\nBubbling\r\n========\r\n\r\nBubbling is the default method of event propagation in JavaScript. When an event is triggered on an element, it is first handled by that element, and then “bubbles” up the DOM tree, triggering the event handlers of its parent elements until it reaches the top of the tree (the document object). This means that if an element has multiple event listeners for the same event, they will be triggered in the order of their parent-child relationship.\r\n\r\nHere is an example of how bubbling works:\r\n\r\n```js\r\n<body>  \r\n  <div>  \r\n    <button>Click me</button>  \r\n  </div>  \r\n</body>\r\n```\r\n\r\n```js\r\ndocument.querySelector('button').addEventListener('click', function(event) {  \r\n  console.log('Button clicked');  \r\n});  \r\ndocument.querySelector('div').addEventListener('click', function(event) {  \r\n  console.log('Div clicked');  \r\n});  \r\ndocument.querySelector('body').addEventListener('click', function(event) {  \r\n  console.log('Body clicked');  \r\n});\r\n```\r\n\r\nIn this example, we have a button element inside a div element inside the body element. When the user clicks the button, the click event is triggered on the button element and then bubbles up to the div element and finally to the body element. As a result, the event handlers for the body, div, and button elements are all triggered, in that order.\r\n\r\nCapturing\r\n=========\r\n\r\nCapturing is the opposite of bubbling. When an event is triggered on an element, it is first handled by the top-level element (the document object) and then “captures” down the DOM tree, triggering the event handlers of its child elements until it reaches the element that triggered the event. This means that if an element has multiple event listeners for the same event, they will be triggered in the order of their child-parent relationship.\r\n\r\nHere is an example of how capturing works:\r\n\r\n```js\r\n<body>  \r\n  <div id=\"parent\">  \r\n    <button id=\"child\">Click me</button>  \r\n  </div>  \r\n</body>\r\n```\r\n\r\n```js\r\nconst parent = document.getElementById('parent');  \r\nconst child = document.getElementById('child');  \r\nparent.addEventListener('click', function(event) {  \r\n  console.log('Parent clicked');  \r\n}, true);  \r\nchild.addEventListener('click', function(event) {  \r\n  console.log('Child clicked');  \r\n}, true);\r\n```\r\n\r\nIn this example, if you click on the “Click me” button, the parent event handler will be called first, and then the child event handler will be called. This is because the event captures down the DOM tree from the root element to its child element.\r\n\r\nStopping Event Propagation\r\n==========================\r\n\r\nSometimes you may want to stop an event from propagating any further up or down the DOM tree. You can do this using the `**stopPropagation**` method of the event object:\r\n\r\n```js\r\n<body>  \r\n  <div id=\"parent\">  \r\n    <button id=\"child\">Click me</button>  \r\n  </div>  \r\n</body>\r\n```\r\n\r\n```js\r\nconst parent = document.getElementById('parent');  \r\nconst child = document.getElementById('child');  \r\nparent.addEventListener('click', function(event) {  \r\n  console.log('Parent clicked');  \r\n});  \r\nchild.addEventListener('click', function(event) {  \r\n  console.log('Child clicked');  \r\n  event.stopPropagation();  \r\n});\r\n```\r\n\r\nIn this example, if you click on the “Click me” button, only the child event handler will be called. This is because the parent event handler stops the event from propagating any further up the DOM tree.\r\n\r\nEvent Delegation\r\n================\r\n\r\nEvent delegation is a technique used in JavaScript to handle events efficiently, especially for situations where there are many elements with similar behavior. Instead of adding event listeners to each individual element, we add a single event listener to a parent element, which then handles the events for all the child elements.\r\n\r\nThis technique takes advantage of the fact that events “bubble up” the DOM hierarchy. When an event occurs on an element, it will first trigger any event listeners attached to that element. Then, the event will “bubble up” to the parent element, triggering any event listeners attached to it. This process continues up the DOM hierarchy until it reaches the root element.\r\n\r\nWith event delegation, we can add a single event listener to the parent element, and then use the `**event.target**` property to identify the child element that actually triggered the event. We can then apply the appropriate behavior based on the target element.\r\n\r\nFor example, let’s say we have a list of items that each have a delete button, and we want to remove an item when its delete button is clicked. Instead of adding an event listener to each individual delete button, we can add a single event listener to the parent element (the list), and use event delegation to identify which delete button was clicked:\r\n\r\n```js\r\n<ul id=\"list\">  \r\n  <li>  \r\n    Item 1 <button class=\"delete-btn\">Delete</button>  \r\n  </li>  \r\n  <li>  \r\n    Item 2 <button class=\"delete-btn\">Delete</button>  \r\n  </li>  \r\n  <li>  \r\n    Item 3 <button class=\"delete-btn\">Delete</button>  \r\n  </li>  \r\n</ul>\r\n```\r\n\r\n```js\r\nconst list = document.getElementById('list');  \r\nlist.addEventListener('click', (event) => {  \r\n  if (event.target.classList.contains('delete-btn')) {  \r\n    const listItem = event.target.closest('li');  \r\n    listItem.remove();  \r\n  }  \r\n});\r\n```\r\n\r\nIn this example, we add a single event listener to the `**list**` element. When a click event occurs, we check if the clicked element has the class `**delete-btn**`. If it does, we use the `**closest**` method to find the nearest `**li**` ancestor element and remove it from the DOM.\r\n\r\nEvent delegation has several advantages over adding event listeners to each individual element:\r\n\r\n1.  It reduces the amount of event listeners needed, which can improve performance and reduce memory usage.\r\n2.  It allows you to handle events for dynamically created elements, as you only need to add the event listener to a parent element that exists in the DOM.\r\n3.  It simplifies your code, as you don’t need to add and remove event listeners whenever elements are added or removed from the DOM.\r\n\r\nUnderstanding Bubbling and Capturing is important for handling events in JavaScript. While Bubbling is the default behavior, Capturing can be useful in some scenarios. It is also important to know how to stop the propagation of an event if we don’t want it to affect other elements in the DOM"},{"id":"handling-forms-in-js","metadata":{"permalink":"/blog/handling-forms-in-js","editUrl":"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/26-handling-forms-in-js.md","source":"@site/blog/javascript/26-handling-forms-in-js.md","title":"Handling Forms in JS","description":"Handling forms is an essential task in web development, and JavaScript provides a powerful and flexible way to handle forms. In this article, we’ll discuss how to handle forms in JavaScript.","date":"2024-05-16T10:39:22.000Z","tags":[{"label":"javascript","permalink":"/blog/tags/javascript"}],"readingTime":5.56,"hasTruncateMarker":true,"authors":[{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"}],"frontMatter":{"slug":"handling-forms-in-js","title":"Handling Forms in JS","authors":{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"},"tags":["javascript"]},"unlisted":false,"prevItem":{"title":"Advance Concepts of Events in JS: Bubbling, Capturing","permalink":"/blog/advance-concepts-of-events-in-js-bubbling-capturing"},"nextItem":{"title":"Working with APIs in JS","permalink":"/blog/working-with-apis-in-js"}},"content":"Handling forms is an essential task in web development, and JavaScript provides a powerful and flexible way to handle forms. In this article, we’ll discuss how to handle forms in JavaScript.\r\n<!-- truncate -->\r\n\r\nGetting Form Elements\r\n=====================\r\n\r\nThe first step in handling forms is to get the form elements. You can get the form elements using the `getElementById` method, which returns the element with the specified ID.\r\n\r\n```js\r\nconst form = document.getElementById('myForm');\r\n```\r\n\r\nOnce you have the form element, you can get the input elements using the `querySelectorAll` method, which returns a NodeList of all the matching elements.\r\n\r\n```js\r\nconst inputs = form.querySelectorAll('input');\r\n```\r\n\r\nHandling Form Submission\r\n========================\r\n\r\nHandling form submission is the most important part of handling forms. You can handle form submission using the `submit` event, which is fired when the user submits the form.\r\n\r\n```js\r\nform.addEventListener('submit', (event) => {  \r\n  event.preventDefault(); // Prevents the form from submitting  \r\n// Your code to handle form submission  \r\n});\r\n```\r\n\r\nValidating Form Input\r\n=====================\r\n\r\nValidating form input is crucial to ensure that the data submitted by the user is valid. You can validate form input using the `checkValidity` method, which returns `true` if the input is valid and `false` if it is not.\r\n\r\n```js\r\n// Check if all inputs are valid  \r\nconst isValid = inputs.every((input) => input.checkValidity());\r\n```\r\n\r\nAccessing Form Data\r\n===================\r\n\r\nTo access the data submitted by the user, you can use the `FormData` API, which provides a way to create a new `FormData` object from a form element.\r\n\r\n```js\r\nconst formData = new FormData(form);\r\n```\r\n\r\nOnce you have the `FormData` object, you can access the form data using the `get` method.\r\n\r\n```js\r\nconst username = formData.get('username');  \r\nconst password = formData.get('password');\r\n```\r\n\r\nReading Text Files\r\n==================\r\n\r\nTo read a text file in JavaScript, we can use the `FileReader` object. This object provides methods for reading files and handling the contents of the file. Here is an example code snippet that demonstrates how to read a text file using `FileReader`:\r\n\r\n```js\r\nconst fileInput = document.querySelector('input[type=\"file\"]');  \r\nfileInput.addEventListener('change', (event) => {  \r\n  const file = event.target.files[0];  \r\n  const reader = new FileReader();  \r\n  reader.onload = () => {  \r\n    console.log(reader.result);  \r\n  };  \r\n  reader.readAsText(file);  \r\n});\r\n```\r\n\r\nIn this example, we first select the file input element using `querySelector`. We then add an event listener to the input element that listens for the `change` event. When the event is triggered, we retrieve the selected file using `event.target.files[0]`. We then create a new instance of `FileReader` and assign it to the `reader` variable.\r\n\r\nWe then define an `onload` event handler for the `reader` object. This event handler is called when the file has been successfully read. In this example, we simply log the contents of the file to the console using `console.log(reader.result)`.\r\n\r\nFinally, we call the `readAsText` method of the `reader` object to read the contents of the file as text.\r\n\r\nReading Binary Files\r\n====================\r\n\r\nReading binary files is a bit more complex than reading text files. Binary files need to be read as an `ArrayBuffer` object, which is a low-level representation of binary data in JavaScript. Here is an example code snippet that demonstrates how to read a binary file using `FileReader`:\r\n\r\n```js\r\nconst fileInput = document.querySelector('input[type=\"file\"]');  \r\nfileInput.addEventListener('change', (event) => {  \r\n  const file = event.target.files[0];  \r\n  const reader = new FileReader();  \r\n  reader.onload = () => {  \r\n    const buffer = reader.result;  \r\n    console.log(new Uint8Array(buffer));  \r\n  };  \r\n  reader.readAsArrayBuffer(file);  \r\n});\r\n```\r\n\r\nIn this example, we use the same basic structure as before, but instead of calling `readAsText`, we call `readAsArrayBuffer`. When the file has been successfully read, the `onload` event handler is called, and we retrieve the contents of the file as an `ArrayBuffer` object using `reader.result`.\r\n\r\nWe then create a new `Uint8Array` object from the `ArrayBuffer` object, which allows us to access the binary data in a more meaningful way. We log the contents of this array to the console using `console.log(new Uint8Array(buffer))`.\r\n\r\nBlob\r\n====\r\n\r\nIn JavaScript, a Blob (Binary Large Object) is an object that represents a file-like object of immutable, raw data. Blobs represent data that isn’t necessarily in a JavaScript-native format, such as images or other binary data.\r\n\r\nA Blob can be created by instantiating the `**Blob**` constructor or by using the `**Blob()**` constructor on a typed array. Here is an example of how to create a new Blob using the `**Blob()**` constructor:\r\n\r\n```js\r\nconst myBlob = new Blob([\"Hello, world!\"], { type: \"text/plain\" });\r\n```\r\n\r\nIn this example, we create a new Blob that contains the string “Hello, world!” and set the type of the Blob to “text/plain”. The resulting Blob can be used in various ways, such as downloading or uploading a file.\r\n\r\nOnce a Blob is created, it can be used to create a URL that can be used as the `**src**` attribute of an image or the `**href**` attribute of a link. Here is an example of how to create a URL from a Blob:\r\n\r\n```js\r\nconst url = URL.createObjectURL(myBlob);\r\n```\r\n\r\nIt’s important to note that Blobs are immutable, meaning their content cannot be modified once they are created. However, you can create a new Blob that contains the modified data and use that instead.\r\n\r\nRevoking a URL created from a Blob is necessary to free up memory used by the URL and make the underlying Blob eligible for garbage collection. When you create a URL from a Blob using `**createObjectURL()**`, a reference is created to the Blob's data. If you don't revoke the URL, the reference will persist even after the Blob is no longer needed, preventing the Blob's data from being garbage collected and potentially leading to memory leaks.\r\n\r\n```js\r\nconst url = URL.createObjectURL(myBlob);  \r\n// Use the URL...  \r\nURL.revokeObjectURL(url);\r\n```\r\n\r\nHere’s an example of how to get a file from a form input and pass it into a Blob:\r\n\r\n```js\r\n// Get the file input element from the form  \r\nconst inputElement = document.getElementById(\"fileInput\");  \r\n// Get the selected file from the input element  \r\nconst file = inputElement.files[0];  \r\n// Create a new FileReader  \r\nconst reader = new FileReader();  \r\n// Set the onload event handler for the FileReader  \r\nreader.onload = function() {  \r\n  // When the FileReader has loaded the file, create a Blob from the result  \r\n  const blob = new Blob([reader.result], { type: file.type });  \r\n    \r\n  // Use the Blob for whatever purpose you need  \r\n  console.log(blob);  \r\n};  \r\n// Read the file as an ArrayBuffer  \r\nreader.readAsArrayBuffer(file);\r\n```\r\n\r\nIn conclusion, handling forms in JavaScript is an essential skill for web developers. By following the tips and techniques outlined in this article, you can handle forms effectively and efficiently. Reading files in JavaScript is a powerful feature that allows us to create more dynamic and interactive web applications. By using the `FileReader` object, we can easily read and manipulate files in both text and binary formats."},{"id":"working-with-apis-in-js","metadata":{"permalink":"/blog/working-with-apis-in-js","editUrl":"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/27-working-with-apis-in-js.md","source":"@site/blog/javascript/27-working-with-apis-in-js.md","title":"Working with APIs in JS","description":"Working with APIs in JavaScript involves making requests to an external server to retrieve or send data. In this blog post, we will discuss the basics of working with APIs in JavaScript, including how to make API requests using different methods and handling responses.","date":"2024-05-16T10:39:22.000Z","tags":[{"label":"javascript","permalink":"/blog/tags/javascript"}],"readingTime":5.025,"hasTruncateMarker":true,"authors":[{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"}],"frontMatter":{"slug":"working-with-apis-in-js","title":"Working with APIs in JS","authors":{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"},"tags":["javascript"]},"unlisted":false,"prevItem":{"title":"Handling Forms in JS","permalink":"/blog/handling-forms-in-js"},"nextItem":{"title":"WebSocket in JS","permalink":"/blog/websocket-in-js"}},"content":"Working with APIs in JavaScript involves making requests to an external server to retrieve or send data. In this blog post, we will discuss the basics of working with APIs in JavaScript, including how to make API requests using different methods and handling responses.\r\n<!-- truncate -->\r\n\r\nFetch Request\r\n=============\r\n\r\nFetch API is a modern interface that allows us to make HTTP requests in JavaScript using the fetch() method. It provides a more flexible and powerful alternative to the older XMLHttpRequest (XHR) object.\r\n\r\nFetch Syntax\r\n============\r\n\r\nThe basic syntax of fetch() method is as follows:\r\n\r\n```js\r\nfetch(url, options);\r\n```\r\n\r\nHere, url is the URL of the resource which you want to fetch and options is an optional object that can include properties like method, headers, body, mode, cache, credentials, redirect, referrer, integrity, and keepalive.\r\n\r\nFetch Example\r\n=============\r\n\r\nHere is an example of fetching data from a URL and parsing the response as JSON:\r\n\r\n```js\r\nfetch('<https://jsonplaceholder.typicode.com/users>')  \r\n  .then(response => response.json())  \r\n  .then(data => console.log(data))  \r\n  .catch(error => console.error(error));\r\n```\r\n\r\nThis code sends a GET request to the given URL and returns a Promise that resolves to the response object. The response.json() method parses the response as JSON and returns another Promise that resolves to the parsed data.\r\n\r\nFetch Options\r\n=============\r\n\r\nThe fetch() method can accept a second argument, an options object, which can be used to customize the request. Some of the most common options are:\r\n\r\n*   method: HTTP method to use for the request (GET, POST, PUT, DELETE, etc.)\r\n*   headers: an object containing any headers to include in the request\r\n*   body: the data to send with the request\r\n*   mode: the mode of the request (cors, no-cors, same-origin, navigate)\r\n*   cache: the cache mode of the request (default, reload, no-cache)\r\n*   credentials: the authentication credentials to include (omit, same-origin, include)\r\n*   redirect: the mode of the redirect (follow, error, manual)\r\n*   referrer: the referrer of the request\r\n*   integrity: the integrity hash of the resource\r\n*   keepalive: a boolean indicating whether or not to send keepalive packets for the request\r\n\r\nBasic Usage\r\n===========\r\n\r\nTo make a simple GET request using the Fetch API, you can use the `**fetch()**` method:\r\n\r\n```js\r\nfetch('<https://api.example.com/data>')  \r\n  .then(response => {  \r\n    if (!response.ok) {  \r\n      throw new Error('Network response was not ok');  \r\n    }  \r\n    return response.json();  \r\n  })  \r\n  .then(data => {  \r\n    console.log(data);  \r\n  })  \r\n  .catch(error => {  \r\n    console.error('There was a problem with the fetch operation:', error);  \r\n  });\r\n```\r\n\r\nRequest Options\r\n===============\r\n\r\nThe `**fetch()**` method also accepts an optional second parameter, which is an options object that allows you to configure the request. Here's an example:\r\n\r\n```js\r\nfetch('<https://api.example.com/data>', {  \r\n  method: 'POST',  \r\n  headers: {  \r\n    'Content-Type': 'application/json'  \r\n  },  \r\n  body: JSON.stringify({  \r\n    name: 'John Doe',  \r\n    email: 'johndoe@example.com'  \r\n  })  \r\n})  \r\n  .then(response => {  \r\n    if (!response.ok) {  \r\n      throw new Error('Network response was not ok');  \r\n    }  \r\n    return response.json();  \r\n  })  \r\n  .then(data => {  \r\n    console.log(data);  \r\n  })  \r\n  .catch(error => {  \r\n    console.error('There was a problem with the fetch operation:', error);  \r\n  });\r\n```\r\n\r\nResponse Options\r\n================\r\n\r\nThe `**Response**` object returned by `**fetch()**` provides several methods for reading the response body as different types of data. For example, you can use the `**text()**` method to read the response body as text, the `**blob()**` method to read it as a Blob object, and the `**arrayBuffer()**` method to read it as an ArrayBuffer.\r\n\r\n```js\r\nfetch('<https://api.example.com/data>')  \r\n  .then(response => {  \r\n    if (!response.ok) {  \r\n      throw new Error('Network response was not ok');  \r\n    }  \r\n    return response.text();  \r\n  })  \r\n  .then(text => {  \r\n    console.log(text);  \r\n  })  \r\n  .catch(error => {  \r\n    console.error('There was a problem with the fetch operation:', error);  \r\n  });\r\n```\r\n\r\n`XMLHTTPRequest`\r\n================\r\n\r\nThe `**XMLHttpRequest**` object is a built-in browser API that allows us to send HTTP requests and receive responses. Here's an example of making a GET request using `**XMLHttpRequest**`:\r\n\r\n```js\r\nconst xhr = new XMLHttpRequest();  \r\nxhr.open('GET', '<https://jsonplaceholder.typicode.com/todos/1>');  \r\nxhr.onload = function() {  \r\n  if (xhr.status === 200) {  \r\n    console.log(JSON.parse(xhr.response));  \r\n  } else {  \r\n    console.log('Request failed. Status code: ' + xhr.status);  \r\n  }  \r\n};  \r\nxhr.send();\r\n```\r\n\r\nHere’s an example of making a POST request using XMLHttpRequest:\r\n\r\n```js\r\nconst xhr = new XMLHttpRequest();  \r\nconst url = '<https://jsonplaceholder.typicode.com/posts>';  \r\nconst data = JSON.stringify({  \r\n  title: 'foo',  \r\n  body: 'bar',  \r\n  userId: 1  \r\n});  \r\nxhr.open('POST', url);  \r\nxhr.setRequestHeader('Content-Type', 'application/json');  \r\nxhr.onload = function() {  \r\n  if (xhr.status === 201) {  \r\n    console.log(JSON.parse(xhr.response));  \r\n  } else {  \r\n    console.log('Request failed. Status code: ' + xhr.status);  \r\n  }  \r\n};  \r\nxhr.send(data);\r\n```\r\n\r\nThe XMLHttpRequest object has a number of methods and properties that allow you to configure and send requests, and handle responses. Here’s an overview of some of the most commonly used methods and properties:\r\n\r\n**Methods:**\r\n\r\n*   `**open(method, url[, async[, user[, password]]])**`: Initializes a new request, setting the HTTP method, URL, and other optional parameters.\r\n*   `**send([body])**`: Sends the request to the server. The optional `**body**` parameter allows you to send data along with the request.\r\n*   `**abort()**`: Aborts the current request.\r\n*   `**setRequestHeader(header, value)**`: Sets a request header.\r\n\r\n**Properties:**\r\n\r\n*   `**onload**`: A callback function that is called when the response has been received.\r\n*   `**readyState**`: The current state of the request.\r\n*   `**response**`: The response body, as an ArrayBuffer, Blob, Document, JSON object, or string, depending on the `**responseType**` property.\r\n*   `**responseType**`: The expected type of the response.\r\n*   `**status**`: The HTTP status code of the response.\r\n*   `**statusText**`: The HTTP status text of the response.\r\n\r\nBy using these methods and properties, you can send requests to a server, receive responses, and manipulate the data as needed in your application.\r\n\r\nBoth Fetch API and XMLHttpRequest (XHR) are used to make HTTP requests in JavaScript. Fetch API is a newer and more modern API, while XHR has been around for a longer time and is considered a legacy API. Fetch API has a simpler syntax and provides a more flexible and powerful interface for making requests, handling responses, and working with data in JSON format. It also supports streaming and has built-in support for CORS. On the other hand, XHR provides more granular control over the request and response, allowing for low-level manipulation of the data. It also supports older browsers and has wider browser support. Overall, both Fetch API and XHR have their strengths and weaknesses, and the choice between them depends on the specific use case and the developer’s preferences."},{"id":"websocket-in-js","metadata":{"permalink":"/blog/websocket-in-js","editUrl":"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/28-websocket-in-js.md","source":"@site/blog/javascript/28-websocket-in-js.md","title":"WebSocket in JS","description":"WebSocket is a protocol that allows for real-time communication between client and server over a single, long-lived connection. Unlike HTTP, which uses a request-response model, WebSocket enables bi-directional communication between the client and server in real-time.","date":"2024-05-16T10:39:22.000Z","tags":[{"label":"javascript","permalink":"/blog/tags/javascript"}],"readingTime":1.635,"hasTruncateMarker":true,"authors":[{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"}],"frontMatter":{"slug":"websocket-in-js","title":"WebSocket in JS","authors":{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"},"tags":["javascript"]},"unlisted":false,"prevItem":{"title":"Working with APIs in JS","permalink":"/blog/working-with-apis-in-js"},"nextItem":{"title":"Browser Data Storage in JS","permalink":"/blog/browser-data-storage-in-js"}},"content":"WebSocket is a protocol that allows for real-time communication between client and server over a single, long-lived connection. Unlike HTTP, which uses a request-response model, WebSocket enables bi-directional communication between the client and server in real-time.\r\n<!-- truncate -->\r\n\r\nJavaScript is a popular language for building web applications that require real-time communication, making WebSocket an important technology to learn for web developers.\r\n\r\nTo use WebSocket in JS, you first need to create a WebSocket object using the WebSocket constructor, passing in the URL of the WebSocket server as a parameter. For example:\r\n\r\n```js\r\nconst socket = new WebSocket('ws://localhost:8080');\r\n```\r\n\r\nOnce you have created a WebSocket object, you need to add event listeners to handle the WebSocket events. Here are the events that we can handle:\r\n\r\n*   `**open**`: This event is fired when the WebSocket connection is established.\r\n*   `**message**`: This event is fired when a message is received from the WebSocket server.\r\n*   `**error**`: This event is fired when an error occurs in the WebSocket connection.\r\n*   `**close**`: This event is fired when the WebSocket connection is closed.\r\n\r\n```js\r\nsocket.addEventListener('open', (event) => {  \r\n  console.log('WebSocket connection established');  \r\n});  \r\nsocket.addEventListener('message', (event) => {  \r\n  console.log('Received message:', event.data);  \r\n});  \r\nsocket.addEventListener('close', (event) => {  \r\n  console.log('WebSocket connection closed');  \r\n});  \r\nsocket.addEventListener('error', (event) => {  \r\n  console.error('WebSocket error:', event);  \r\n});\r\n```\r\n\r\nTo send a message from the client to the server, you can use the `send()` method on the WebSocket object:\r\n\r\n```js\r\nconst message = 'Hello, WebSocket!';  \r\nsocket.send(message);\r\n```\r\n\r\nTo receive data from the server, we need to handle the `**message**` event of the WebSocket object. Here's an example of how to receive data from the server:\r\n\r\n```js\r\nsocket.addEventListener('message', function(event) {  \r\n  const message = event.data;  \r\n  console.log('Message received: ' + message);  \r\n});\r\n```\r\n\r\nOn the server-side, you can use libraries like `ws` or `socket.io` to handle WebSocket connections in Node.js.\r\n\r\nWebSocket is a powerful technology that enables real-time communication between client and server. With JavaScript, you can easily create WebSocket connections and handle incoming messages and errors."},{"id":"browser-data-storage-in-js","metadata":{"permalink":"/blog/browser-data-storage-in-js","editUrl":"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/29-browser-data-storage-in-js.md","source":"@site/blog/javascript/29-browser-data-storage-in-js.md","title":"Browser Data Storage in JS","description":"JavaScript provides various options for storing data in the browser. These storage options are used to store data temporarily or permanently. In this article, we will explore different ways of storing data in the browser using JavaScript.","date":"2024-05-16T10:39:22.000Z","tags":[{"label":"javascript","permalink":"/blog/tags/javascript"}],"readingTime":2.89,"hasTruncateMarker":true,"authors":[{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"}],"frontMatter":{"slug":"browser-data-storage-in-js","title":"Browser Data Storage in JS","authors":{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"},"tags":["javascript"]},"unlisted":false,"prevItem":{"title":"WebSocket in JS","permalink":"/blog/websocket-in-js"},"nextItem":{"title":"Commenting and Debugging in JS","permalink":"/blog/commenting-and-debugging-in-js"}},"content":"JavaScript provides various options for storing data in the browser. These storage options are used to store data temporarily or permanently. In this article, we will explore different ways of storing data in the browser using JavaScript.\r\n<!-- truncate -->\r\n\r\n## Cookies\r\n\r\nCookies are small pieces of data that are stored in the browser. Cookies can be used to store user preferences, login information, and other data that needs to be persisted. Cookies can be set with an expiration date, after which they are automatically deleted.\r\n\r\nCookies can be created and accessed using the `document.cookie` property in JavaScript.\r\n\r\n```js\r\n// Setting a Cookie  \r\ndocument.cookie = 'key=value';  \r\n// Retrieving a Cookie  \r\nlet username = document.cookie.split('=')[1]; // get the value after the '=' sign\r\n```\r\n\r\n## Local Storage\r\n\r\nLocal Storage is a type of storage that allows storing data in the browser permanently. The data stored in Local Storage remains even after the browser is closed. It can be used to store user preferences, login information, and other data that needs to be persisted.\r\n\r\nLocal Storage is implemented using the `localStorage` object in JavaScript. Data can be stored in Local Storage using the `setItem()` method and retrieved using the `getItem()` method.\r\n\r\n```js\r\n// Storing Data in Local Storage  \r\nlocalStorage.setItem('key', 'value');  \r\n// Retrieving Data from Local Storage  \r\nconst value = localStorage.getItem('key');\r\n```\r\n\r\n## Session Storage\r\n\r\nSession Storage is similar to Local Storage but it stores data only for the duration of the session. Session Storage is cleared when the browser is closed or the session ends. It is useful for storing data that needs to be accessed during a session, such as shopping cart items or form data.\r\n\r\nSession Storage is implemented using the `sessionStorage` object in JavaScript. Data can be stored in Session Storage using the `setItem()` method and retrieved using the `getItem()` method.\r\n\r\n```js\r\n// Storing Data in Session Storage  \r\nsessionStorage.setItem('key', 'value');  \r\n// Retrieving Data from Session Storage  \r\nconst value = sessionStorage.getItem('key');\r\n```\r\n\r\n## IndexedDB\r\n\r\nTo use IndexedDB, you need to first open a connection to a database. Here’s an example of opening a database connection:\r\n\r\n```js\r\nlet request = indexedDB.open(\"myDatabase\", 1);  \r\nrequest.onerror = function(event) {  \r\n  // handle errors  \r\n};  \r\nrequest.onupgradeneeded = function(event) {  \r\n  let db = event.target.result;  \r\n  let objectStore = db.createObjectStore(\"users\", { keyPath: \"id\" });  \r\n  // create indexes if needed  \r\n};  \r\nrequest.onsuccess = function(event) {  \r\n  let db = event.target.result;  \r\n  // use the database  \r\n};\r\n```\r\n\r\nOnce you have opened a connection to the database, you can create object stores to store your data. Here’s an example of adding a record to an object store:\r\n\r\n```js\r\nlet transaction = db.transaction([\"users\"], \"readwrite\");  \r\nlet objectStore = transaction.objectStore(\"users\");  \r\nlet user = { id: 1, username: \"John\" };  \r\nlet request = objectStore.add(user);  \r\nrequest.onerror = function(event) {  \r\n  // handle errors  \r\n};  \r\nrequest.onsuccess = function(event) {  \r\n  // record added successfully  \r\n};\r\n```\r\n\r\nTo retrieve data from an object store, you can use the `**objectStore.get()**` method:\r\n\r\n```js\r\nlet transaction = db.transaction([\"users\"], \"readonly\");  \r\nlet objectStore = transaction.objectStore(\"users\");  \r\nlet request = objectStore.get(1);  \r\nrequest.onerror = function(event) {  \r\n  // handle errors  \r\n};  \r\nrequest.onsuccess = function(event) {  \r\n  let user = request.result;  \r\n  // use the user object  \r\n};\r\n```\r\n\r\nIn conclusion, JavaScript provides various options for storing data in the browser. Local Storage and Session Storage can be used to store data permanently or temporarily, respectively. Cookies are another option for storing data in the browser. The choice of storage option depends on the type of data that needs to be persisted and the duration for which it needs to be persisted."},{"id":"commenting-and-debugging-in-js","metadata":{"permalink":"/blog/commenting-and-debugging-in-js","editUrl":"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/3-commenting-and-debugging-in-js.md","source":"@site/blog/javascript/3-commenting-and-debugging-in-js.md","title":"Commenting and Debugging in JS","description":"When it comes to programming in JavaScript, commenting and debugging are two important tasks that every developer should be familiar with.","date":"2024-05-16T10:39:22.000Z","tags":[{"label":"javascript","permalink":"/blog/tags/javascript"}],"readingTime":5.345,"hasTruncateMarker":true,"authors":[{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"}],"frontMatter":{"slug":"commenting-and-debugging-in-js","title":"Commenting and Debugging in JS","authors":{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"},"tags":["javascript"]},"unlisted":false,"prevItem":{"title":"Browser Data Storage in JS","permalink":"/blog/browser-data-storage-in-js"},"nextItem":{"title":"Operators and Expressions in JS","permalink":"/blog/operators-and-expressions-in-js"}},"content":"When it comes to programming in JavaScript, commenting and debugging are two important tasks that every developer should be familiar with.\r\n<!-- truncate -->\r\n\r\nCommenting in JS\r\n================\r\n\r\nCommenting in JavaScript is the process of adding notes or explanations within the code. These comments are not executed by the browser and are only meant for developers to read.\r\n\r\nIn JS, there are two ways to add comments:\r\n\r\nSingle-line comments\r\n--------------------\r\n\r\nSingle-line comments start with ‘//’ and continue until the end of the line. For example:\r\n\r\n```js\r\n// This is a single-line comment\r\n```\r\n\r\nMulti-line comments\r\n-------------------\r\n\r\nMulti-line comments start with ‘/_’ and end with ‘_/’. They can span across multiple lines. For example:\r\n\r\n```js\r\n/*  \r\nThis is a multi-line comment  \r\nIt can span across multiple lines  \r\n*/\r\n```\r\n\r\nHere’s an example of a function definition with JSDoc comments:\r\n\r\n```js\r\n/**\r\n * Adds two numbers together and returns the result  \r\n * @param {number} num1 - The first number to add  \r\n * @param {number} num2 - The second number to add  \r\n * @returns {number} The sum of the two numbers  \r\n */  \r\nfunction addNumbers(num1, num2) {  \r\n  return num1 + num2;  \r\n}  \r\n// Example usage  \r\nlet result = addNumbers(5, 7);  \r\nconsole.log(result); // 12\r\n```\r\n\r\nAdding comments to your code can make it more readable and easier to understand for other developers who may have to work on the same codebase.\r\n\r\nDebugging in JS\r\n===============\r\n\r\nDebugging in JavaScript is the process of finding and fixing errors or bugs in the code. There are different ways to debug JavaScript code, including:\r\n\r\nConsole\r\n-------\r\n\r\nThe console object in JavaScript provides a way to output messages to the browser’s console. This is useful for debugging purposes or for displaying information to the user. Here are some of the different functions available on the console object:\r\n\r\n1.  console.log(): Outputs a message to the console. This method is used to log messages, variables or other information to the console.\r\n\r\n```js\r\nconsole.log('Hello, world!'); // Hello, world!  \r\n  \r\nconst name = 'John';  \r\nconsole.log(`My name is ${name}.`); // My name is John.\r\n```\r\n\r\n2\\. console.error(): Outputs an error message to the console. This method is used to log error messages to the console.\r\n\r\n```js\r\nconsole.error('Something went wrong.'); // Something went wrong.\r\n```\r\n\r\n3\\. console.warn(): Outputs a warning message to the console. This method is used to log warning messages to the console.\r\n\r\n```js\r\nconsole.warn('This could be a problem.'); // This could be a problem.\r\n```\r\n\r\n4\\. console.info(): Outputs an informational message to the console. This method is used to log informational messages to the console.\r\n\r\n```js\r\nconsole.info('The sky is blue.'); // The sky is blue.\r\n```\r\n\r\n5\\. console.debug(): Outputs a debug message to the console. This method is used to log debug messages to the console.\r\n\r\n```js\r\nconsole.debug('This is a debug message.'); // This is a debug message.\r\n```\r\n\r\n6\\. console.assert(): Writes an error message to the console if the assertion is false. This method is used to check assertions and log error messages if they are false.\r\n\r\n```js\r\nconst num1 = 5;  \r\nconst num2 = 10;  \r\n  \r\nconsole.assert(num1 < num2, 'num1 is not less than num2.'); // No output  \r\n  \r\nconsole.assert(num1 > num2, 'num1 is not greater than num2.'); // num1 is not greater than num2.\r\n```\r\n\r\n7\\. console.clear(): Clears the console. This method is used to clear the console.\r\n\r\n```js\r\nconsole.clear(); // Clears the console\r\n```\r\n\r\n8\\. console.count(): Outputs the number of times that the count() method has been called with the given label. This method is used to count how many times a specific label has been counted.\r\n\r\n```js\r\nfunction foo() {  \r\n  console.count('foo');  \r\n}  \r\n  \r\nfoo(); // foo: 1  \r\nfoo(); // foo: 2  \r\nfoo(); // foo: 3\r\n```\r\n\r\n9\\. console.group(): Groups together a set of console messages. This method is used to group console messages together.\r\n\r\n```js\r\nconsole.group('Group');  \r\nconsole.log('Hello, world!');  \r\nconsole.warn('This could be a problem.');  \r\nconsole.groupEnd();\r\n```\r\n\r\n10\\. console.groupCollapsed(): Groups together a set of console messages, but collapses the group initially. This method is used to group console messages together and collapse them initially.\r\n\r\n```js\r\nconsole.groupCollapsed('Group');  \r\nconsole.log('Hello, world!');  \r\nconsole.warn('This could be a problem.');  \r\nconsole.groupEnd();\r\n```\r\n\r\n11\\. console.groupEnd(): Ends the current group of console messages. This method is used to end a group of console messages.\r\n\r\n```js\r\nconsole.group('Group');  \r\nconsole.log('Hello, world!');  \r\nconsole.warn('This could be a problem.');  \r\nconsole.groupEnd();  \r\nconsole.log('Hello, world!'); // Not part of the group\r\n```\r\n\r\n12\\. console.table(): Outputs an array or object as a table to the console. This method is used to log an array or object in tabular form.\r\n\r\n```js\r\nconst fruits = ['Apple', 'Banana', 'Orange'];  \r\nconsole.table(fruits);  \r\n  \r\nconst person = {  \r\n  name: 'John',  \r\n  age: 30,  \r\n  city: 'New York'  \r\n};  \r\nconsole.table(person);\r\n```\r\n\r\n13\\. console.time(): Starts a timer in the console. This method is used to start a timer.\r\n\r\n```js\r\nconsole.time('Timer');  \r\n// Code to be timed goes here  \r\nconsole.timeEnd('Timer');\r\n```\r\n\r\n14\\. console.timeEnd(): Ends a timer in the console. This method is used to end a timer.\r\n\r\n```js\r\nconsole.time('Timer');  \r\n// Code to be timed goes here  \r\nconsole.timeEnd('Timer');\r\n```\r\n\r\n15\\. console.trace(): Outputs a stack trace to the console. This method is used to log a stack trace to the console.\r\n\r\n```js\r\nfunction foo() {  \r\n  console.trace();  \r\n}  \r\n  \r\nfunction bar() {  \r\n  foo();  \r\n}  \r\n  \r\nbar();\r\n```\r\n\r\n16\\. console.dir(): Outputs a directory of an object to the console. This method is used to log a directory of an object to the console.\r\n\r\n```js\r\nconst person = {  \r\n  name: 'John',  \r\n  age: 30,  \r\n  city: 'New York'  \r\n};  \r\n  \r\nconsole.dir(person);\r\n```\r\n\r\n17\\. console.profile(): Starts the profiler in the console. This method is used to start the profiler.\r\n\r\n```js\r\nconsole.profile('Profile');  \r\n// Code to be profiled goes here  \r\nconsole.profileEnd('Profile');\r\n```\r\n\r\n18\\. console.profileEnd(): Ends the profiler in the console. This method is used to end the profiler.\r\n\r\n```js\r\nconsole.profile('Profile');  \r\n// Code to be profiled goes here  \r\nconsole.profileEnd('Profile');\r\n```\r\n\r\nUsing breakpoints\r\n-----------------\r\n\r\nAnother way to debug JavaScript code is by using breakpoints. Breakpoints are markers that you can set in the code, which will pause the execution of the code at that point. This allows you to inspect the values of variables and objects at that point in time.\r\n\r\nUsing the debugger statement\r\n----------------------------\r\n\r\nThe debugger statement is a statement in JavaScript that stops the execution of the code and launches the browser’s debugging tool. For example:\r\n\r\n```js\r\nlet x = 10;  \r\ndebugger;  \r\nconsole.log(x);\r\n```\r\n\r\nWhen the code reaches the debugger statement, it will pause execution and launch the browser’s debugging tool.\r\n\r\nDebugging in JavaScript is an essential skill for every developer. It helps to identify and fix errors in the code, making it more efficient and reliable."},{"id":"operators-and-expressions-in-js","metadata":{"permalink":"/blog/operators-and-expressions-in-js","editUrl":"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/4-operators-and-expressions-in-js.md","source":"@site/blog/javascript/4-operators-and-expressions-in-js.md","title":"Operators and Expressions in JS","description":"JavaScript is a powerful programming language that allows you to create dynamic and interactive web pages. One of the key features of JavaScript is its use of operators and expressions.","date":"2024-05-16T10:39:22.000Z","tags":[{"label":"javascript","permalink":"/blog/tags/javascript"}],"readingTime":5.31,"hasTruncateMarker":true,"authors":[{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"}],"frontMatter":{"slug":"operators-and-expressions-in-js","title":"Operators and Expressions in JS","authors":{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"},"tags":["javascript"]},"unlisted":false,"prevItem":{"title":"Commenting and Debugging in JS","permalink":"/blog/commenting-and-debugging-in-js"},"nextItem":{"title":"Control Flow Statements in JS","permalink":"/blog/control-flow-statements-in-js"}},"content":"JavaScript is a powerful programming language that allows you to create dynamic and interactive web pages. One of the key features of JavaScript is its use of operators and expressions.\r\n<!-- truncate -->\r\n\r\nOperators in JS\r\n===============\r\n\r\nOperators in JavaScript are used to perform various operations on values. JavaScript has several types of operators, including arithmetic, comparison, logical, assignment, bitwise, and conditional operators.\r\n\r\nArithmetic Operators\r\n====================\r\n\r\nArithmetic operators are used to perform mathematical calculations on numeric values. These operators include addition (+), subtraction (-), multiplication (*), division (/), and modulus (%).\r\n\r\n```js\r\nlet num1 = 10;  \r\nlet num2 = 20;  \r\n// Addition  \r\nlet sum = num1 + num2;  \r\nconsole.log(sum); // 30  \r\n// Subtraction  \r\nlet difference = num1 - num2;  \r\nconsole.log(difference); // -10  \r\n// Multiplication  \r\nlet product = num1 * num2;  \r\nconsole.log(product); // 200  \r\n// Division  \r\nlet quotient = num2 / num1;  \r\nconsole.log(quotient); // 2  \r\n// Modulo (Remainder)  \r\nlet remainder = num2 % num1;  \r\nconsole.log(remainder); // 0  \r\n// Increment  \r\nnum1++;  \r\nconsole.log(num1); // 11  \r\n// Decrement  \r\nnum2--;  \r\nconsole.log(num2); // 19\r\n```\r\n\r\nComparison Operators\r\n====================\r\n\r\nComparison operators are used to compare two values and return a Boolean value of true or false. These operators include `==`, `!=`, `>`, `<`, `>=`, and `<=`.\r\n\r\n```js\r\nlet num1 = 10;  \r\nlet num2 = 20;  \r\n// Equal to  \r\nconsole.log(num1 == num2); // false  \r\n// Not equal to  \r\nconsole.log(num1 != num2); // true  \r\n// Greater than  \r\nconsole.log(num2 > num1); // true  \r\n// Less than  \r\nconsole.log(num1 < num2); // true  \r\n// Greater than or equal to  \r\nconsole.log(num2 >= num1); // true  \r\n// Less than or equal to  \r\nconsole.log(num1 <= num2); // true\r\n```\r\n\r\nLogical Operators\r\n=================\r\n\r\nLogical operators are used to evaluate two or more expressions and return a Boolean value of true or false. These operators include &&, ||, and !.\r\n\r\n```js\r\nlet num1 = 10;  \r\nlet num2 = 20;  \r\nlet num3 = 30;  \r\n// Logical AND  \r\nconsole.log(num1 < num2 && num2 < num3); // true  \r\n// Logical OR  \r\nconsole.log(num1 < num2 || num2 > num3); // true  \r\n// Logical NOT  \r\nconsole.log(!(num1 == num2)); // true\r\n```\r\n\r\nAssignment Operators\r\n====================\r\n\r\nAssignment operators are used to assign values to variables. These operators include `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `<<=`, `>>=`, `&=`, `^=`, and `|=`.\r\n\r\n```js\r\nlet num1 = 10;  \r\nlet num2 = 20;  \r\n// Assignment  \r\nnum1 = num2;  \r\nconsole.log(num1); // 20  \r\n// Addition assignment  \r\nnum1 += num2;  \r\nconsole.log(num1); // 40  \r\n// Subtraction assignment  \r\nnum1 -= num2;  \r\nconsole.log(num1); // 20  \r\n// Multiplication assignment  \r\nnum1 *= num2;  \r\nconsole.log(num1); // 400  \r\n// Division assignment  \r\nnum1 /= num2;  \r\nconsole.log(num1); // 20  \r\n// Modulo (Remainder) assignment  \r\nnum1 %= num2;  \r\nconsole.log(num1); // 0\r\n```\r\n\r\nBitwise Operators\r\n=================\r\n\r\nBitwise operators are used to perform bitwise operations on values. These operators include `&`, `|`, `^`, `~`, `<<`, and `>>`.\r\n\r\n```js\r\nlet num1 = 10;  \r\nlet num2 = 20;  \r\n// Bitwise AND  \r\nconsole.log(num1 & num2); // 0  \r\n// Bitwise OR  \r\nconsole.log(num1 | num2); // 30  \r\n// Bitwise XOR  \r\nconsole.log(num1 ^ num2); // 30  \r\n// Bitwise NOT  \r\nconsole.log(~num1); // -11  \r\n// Left shift  \r\nconsole.log(num1 << 1); // 20  \r\n// Right shift  \r\nconsole.log(num1 >> 1); // 5\r\n```\r\n\r\nConditional Operator\r\n====================\r\n\r\nConditional operators are used to assign a value to a variable based on a condition. The syntax for the conditional operator is as follows:\r\n\r\n```js\r\nlet age = 20;  \r\nlet status = (age >= 18) ? \"adult\" : \"minor\";  \r\nconsole.log(status); // \"adult\"\r\n```\r\n\r\nNullish Coalescing Operator\r\n===========================\r\n\r\nThe Nullish Coalescing Operator (??) is used to check if a value is null or undefined, and if it is, it returns a default value instead.\r\n\r\n```js\r\nlet num1 = 10;  \r\nlet num2 = null;  \r\n// Using the Nullish Coalescing Operator  \r\nlet result = num1 ?? 20;  \r\nconsole.log(result); // 10  \r\nresult = num2 ?? 20;  \r\nconsole.log(result); // 20\r\n```\r\n\r\nExpressions in JS\r\n=================\r\n\r\nExpressions in JavaScript are combinations of values, variables, and operators that are evaluated to produce a value. There are several types of expressions in JavaScript, including arithmetic expressions, string expressions, Boolean expressions, and object expressions.\r\n\r\nArithmetic Expressions\r\n======================\r\n\r\nArithmetic expressions are expressions that use arithmetic operators to perform mathematical calculations on numeric values.\r\n\r\n```js\r\nlet num1 = 10;  \r\nlet num2 = 20;  \r\n// Addition  \r\nlet result1 = num1 + num2;  \r\nconsole.log(result1); // 30  \r\n// Subtraction  \r\nlet result2 = num1 - num2;  \r\nconsole.log(result2); // -10  \r\n// Multiplication  \r\nlet result3 = num1 * num2;  \r\nconsole.log(result3); // 200  \r\n// Division  \r\nlet result4 = num1 / num2;  \r\nconsole.log(result4); // 0.5  \r\n// Modulo (Remainder)  \r\nlet result5 = num1 % num2;  \r\nconsole.log(result5); // 10\r\n```\r\n\r\nString Expressions\r\n==================\r\n\r\nString expressions are expressions that concatenate two or more strings together using the + operator.\r\n\r\n```js\r\nlet firstName = \"John\";  \r\nlet lastName = \"Doe\";  \r\n// Concatenation  \r\nlet fullName = firstName + \" \" + lastName;  \r\nconsole.log(fullName); // \"John Doe\"  \r\n// String Length  \r\nlet nameLength = fullName.length;  \r\nconsole.log(nameLength); // 8  \r\n// Accessing Characters  \r\nlet firstChar = fullName[0];  \r\nconsole.log(firstChar); // \"J\"  \r\n// Substring  \r\nlet firstNameSubstring = fullName.substring(0, 4);  \r\nconsole.log(firstNameSubstring); // \"John\"  \r\n// Replacing Characters  \r\nlet replacedName = fullName.replace(\"Doe\", \"Smith\");  \r\nconsole.log(replacedName); // \"John Smith\"\r\n```\r\n\r\nBoolean Expressions\r\n===================\r\n\r\nBoolean expressions are expressions that evaluate to either true or false.\r\n\r\n```js\r\nlet num1 = 10;  \r\nlet num2 = 20;  \r\n// Greater Than  \r\nlet greaterThan = num2 > num1;  \r\nconsole.log(greaterThan); // true  \r\n// Less Than  \r\nlet lessThan = num1 < num2;  \r\nconsole.log(lessThan); // true  \r\n// Greater Than or Equal To  \r\nlet greaterThanOrEqualTo = num1 >= num2;  \r\nconsole.log(greaterThanOrEqualTo); // false  \r\n// Less Than or Equal To  \r\nlet lessThanOrEqualTo = num2 <= num1;  \r\nconsole.log(lessThanOrEqualTo); // false  \r\n// Equal To  \r\nlet equalTo = num1 == num2;  \r\nconsole.log(equalTo); // false  \r\n// Not Equal To  \r\nlet notEqualTo = num1 != num2;  \r\nconsole.log(notEqualTo); // true\r\n```\r\n\r\nObject expressions are expressions that create a new object using the new operator.\r\n\r\n```js\r\nlet person = {  \r\n  firstName: \"John\",  \r\n  lastName: \"Doe\",  \r\n  age: 30,  \r\n  hobbies: [\"reading\", \"swimming\", \"hiking\"],  \r\n  address: {  \r\n    street: \"123 Main St\",  \r\n    city: \"Anytown\",  \r\n    state: \"CA\",  \r\n    zip: \"12345\"  \r\n  },  \r\n  isStudent: false  \r\n};  \r\nconsole.log(person.firstName); // \"John\"  \r\nconsole.log(person.age); // 30  \r\nconsole.log(person.hobbies[1]); // \"swimming\"  \r\nconsole.log(person.address.city); // \"Anytown\"  \r\nconsole.log(person.isStudent); // false  \r\n// Adding a new property to the object  \r\nperson.email = \"john.doe@example.com\";  \r\nconsole.log(person.email); // \"john.doe@example.com\"  \r\n// Modifying an existing property of the object  \r\nperson.age = 35;  \r\nconsole.log(person.age); // 35  \r\n// Deleting a property of the object  \r\ndelete person.isStudent;  \r\nconsole.log(person.isStudent); // undefined\r\n```\r\n\r\nOperators and expressions are essential components of JavaScript programming. By understanding how operators and expressions work in JS, you can create powerful and dynamic web pages that are sure to impress your users."},{"id":"control-flow-statements-in-js","metadata":{"permalink":"/blog/control-flow-statements-in-js","editUrl":"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/5-control-flow-statements-in-js.md","source":"@site/blog/javascript/5-control-flow-statements-in-js.md","title":"Control Flow Statements in JS","description":"JavaScript is a programming language that allows developers to build complex web applications. Control flow statements are one of the most important features in JavaScript.","date":"2024-05-16T10:39:22.000Z","tags":[{"label":"javascript","permalink":"/blog/tags/javascript"}],"readingTime":3.04,"hasTruncateMarker":true,"authors":[{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"}],"frontMatter":{"slug":"control-flow-statements-in-js","title":"Control Flow Statements in JS","authors":{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"},"tags":["javascript"]},"unlisted":false,"prevItem":{"title":"Operators and Expressions in JS","permalink":"/blog/operators-and-expressions-in-js"},"nextItem":{"title":"TypeConversion in JS","permalink":"/blog/typeconversion-in-js"}},"content":"JavaScript is a programming language that allows developers to build complex web applications. Control flow statements are one of the most important features in JavaScript.\r\n<!-- truncate -->\r\n\r\nControl flow statements are used to control the flow of execution in a program. They are used to make decisions, execute loops, and handle errors. There are three types of control flow statements in JavaScript: conditional statements, loops, and try/catch statements.\r\n\r\nConditional Statements\r\n======================\r\n\r\nConditional statements are used to execute different actions based on different conditions.\r\n\r\n1.  `if` statement:\r\n\r\n```js\r\nlet x = 5;  \r\nif (x < 10) {  \r\n  console.log(\"x is less than 10\");  \r\n}\r\n```\r\n\r\n2. `**if...else**` statement:\r\n\r\n```js\r\nlet temperature = 25;  \r\nif (temperature < 20) {  \r\n  console.log(\"It's cold outside\");  \r\n} else {  \r\n  console.log(\"It's warm outside\");  \r\n}\r\n```\r\n\r\n3\\. `**if...else if...else**` statement:\r\n\r\n```js\r\nlet grade = 85;  \r\nif (grade >= 90) {  \r\n  console.log(\"A\");  \r\n} else if (grade >= 80) {  \r\n  console.log(\"B\");  \r\n} else if (grade >= 70) {  \r\n  console.log(\"C\");  \r\n} else {  \r\n  console.log(\"F\");  \r\n}\r\n```\r\n\r\n4\\. Nested `**if**` statements:\r\n\r\n```js\r\nlet age = 20;  \r\nlet hasLicense = true;  \r\nif (age >= 18) {  \r\n  if (hasLicense) {  \r\n    console.log(\"You can drive\");  \r\n  } else {  \r\n    console.log(\"You can't drive without a license\");  \r\n  }  \r\n} else {  \r\n  console.log(\"You're too young to drive\");  \r\n}\r\n```\r\n\r\nIn JavaScript, any value that is not explicitly `**false**`, `**0**`, `**null**`, `**undefined**`, `**NaN**`, or an empty string (`**\"\"**`) is considered \"truthy\". This means that when such a value is used in an `**if**` statement, it will be evaluated as `**true**`.\r\n\r\n```js\r\nif (\"hello\") {  \r\n  console.log(\"This will be printed\");  \r\n}  \r\n  \r\nif ([]) {  \r\n  console.log(\"This will also be printed\");  \r\n}\r\n```\r\n\r\nLoops\r\n=====\r\n\r\nLoops are used to execute a block of code multiple times. JavaScript supports different types of loops, including the for loop, while loop, and do-while loop.\r\n\r\nfor loop\r\n========\r\n\r\nThe for loop is the most commonly used loop in JavaScript. It is used to iterate over an array or execute a block of code a specific number of times.\r\n\r\n```js\r\nfor (let i = 0; i < 5; i++) {  \r\n  console.log(i);  \r\n}  \r\n// nested for loop  \r\nfor (let i = 0; i < 5; i++) {  \r\n  for (let j= 0; j< 5; j++) {  \r\n    console.log(i, j);  \r\n  }  \r\n}\r\n```\r\n\r\nThe for loop parameters are optional\r\n\r\n```js\r\nfor(;;){  \r\n  // infinite loop  \r\n  console.log(\"printing\")  \r\n}\r\n```\r\n\r\nwhile loop\r\n==========\r\n\r\nThe while loop is used to execute a block of code as long as a condition is true.\r\n\r\n```js\r\nlet i = 0;  \r\nwhile (i < 5) {  \r\n  console.log(i);  \r\n  i++;  \r\n}\r\n```\r\n\r\ndo-while loop\r\n=============\r\n\r\nThe do-while loop is similar to the while loop, but it executes the code block at least once before checking the condition.\r\n\r\n```js\r\nlet i = 1;  \r\ndo {  \r\n  console.log(i);  \r\n  i++;  \r\n} while (i <= 5);\r\n```\r\n\r\nBreak\r\n=====\r\n\r\nThe `**break**` statement is used to immediately terminate a loop and continue executing code outside of the loop. Here's an example of using `**break**` to terminate a loop when a condition is met:\r\n\r\n```js\r\nfor (let i = 0; i < 10; i++) {  \r\n  if (i === 5) {  \r\n    break;  \r\n  }  \r\n  console.log(i);  \r\n}\r\n```\r\n\r\nContinue\r\n========\r\n\r\nThe `**continue**` statement is used to skip over an iteration of a loop and continue with the next iteration. Here's an example of using `**continue**` to skip over even numbers in a loop:\r\n\r\n```js\r\nfor (let i = 0; i < 10; i++) {  \r\n  if (i % 2 === 0) {  \r\n    continue;  \r\n  }  \r\n  console.log(i);  \r\n}\r\n```\r\n\r\nIn conclusion, control flow statements are essential in JavaScript programming. They allow developers to make decisions, execute loops, and handle errors. By understanding how to use these statements, developers can write more efficient and effective code."},{"id":"typeconversion-in-js","metadata":{"permalink":"/blog/typeconversion-in-js","editUrl":"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/6-typeconversion-in-js.md","source":"@site/blog/javascript/6-typeconversion-in-js.md","title":"TypeConversion in JS","description":"When we need to convert a value from one data type to another in JavaScript, we can perform either implicit or explicit type conversion. Implicit type conversion is performed automatically by JavaScript, while explicit type conversion is performed manually using built-in methods. Some examples of explicit type conversion are Boolean Conversion Boolean(), Number Conversion Number(), and String Conversion String().","date":"2024-05-16T10:39:22.000Z","tags":[{"label":"javascript","permalink":"/blog/tags/javascript"}],"readingTime":4.06,"hasTruncateMarker":true,"authors":[{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"}],"frontMatter":{"slug":"typeconversion-in-js","title":"TypeConversion in JS","authors":{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"},"tags":["javascript"]},"unlisted":false,"prevItem":{"title":"Control Flow Statements in JS","permalink":"/blog/control-flow-statements-in-js"},"nextItem":{"title":"Functions in JS: named, anonymous","permalink":"/blog/functions-in-js-named-anonymous"}},"content":"When we need to convert a value from one data type to another in JavaScript, we can perform either implicit or explicit type conversion. Implicit type conversion is performed automatically by JavaScript, while explicit type conversion is performed manually using built-in methods. Some examples of explicit type conversion are Boolean Conversion Boolean(), Number Conversion Number(), and String Conversion String().\r\n<!-- truncate -->\r\n\r\n1.  **Explicit type conversion** (also known as casting) is performed manually by the developer using built-in methods.\r\n\r\n**Boolean Conversion** `**Boolean()**`\r\n\r\nThe rule for converting a number to a boolean value is simple: any non-zero number is considered truthy, and the number `**0**` (or `**-0**`) and `NaN` is considered falsy.\r\n\r\n```js\r\nBoolean(0);  // false  \r\nBoolean(-0); // false  \r\nBoolean(1);  // true  \r\nBoolean(-1); // true  \r\nBoolean(42); // true\r\n```\r\n\r\nAn empty string (`**\"\"**`) even having whitespaces is considered falsy, while any non-empty string is truthy.\r\n\r\n```js\r\nBoolean(\"\");      // false  \r\nBoolean(\"hello\"); // true  \r\nBoolean(\"0\");     // true  \r\nBoolean(\"false\"); // true  \r\nBoolean(\"true\");  // true\r\n```\r\n\r\nAll objects will always be truthy no matter it is empty or filled\r\n\r\n```js\r\nBoolean([]);            // true  \r\nBoolean([1, 2, 3]);     // true  \r\nBoolean([\"hello\", 42]); // true  \r\nBoolean({});            // true  \r\nBoolean({name: \"John\"});// true\r\n```\r\n\r\n**Number Conversion** `**Number()**`\r\n\r\nWhen a boolean value is converted to a number, true is converted to 1 and false is converted to 0.\r\n\r\n```js\r\nNumber(true);  // 1  \r\nNumber(false); // 0\r\n```\r\n\r\nWhen a string is converted to a number, the following rules apply:\r\n\r\n*   If the string contains only numeric characters (0–9) or a decimal point, it is converted to a corresponding number.\r\n*   If the string is empty or contains only whitespace characters, it is converted to `**0**`.\r\n*   If the string contains any non-numeric characters other than a decimal point, it is converted to `**NaN**` (Not a Number).\r\n\r\n```js\r\nNumber(\"42\");      // 42  \r\nNumber(\"3.14\");    // 3.14  \r\nNumber(\"\");        // 0  \r\nNumber(\"   \");     // 0  \r\nNumber(\"123abc\");  // NaN\r\n```\r\n\r\nIf an array has only one element and that element is a number, then the array can be directly converted to a number and if array is empty, then the array will convert to zero.\r\n\r\n```js\r\nlet arr = [42];  \r\nconsole.log(Number(arr)); // 42  \r\nconsole.log(+arr);        // 42  \r\nconsole.log(Number([]));  // 0\r\n```\r\n\r\n**String Conversion** `**String()**`\r\n\r\nIf primitive is converted to string, then value will be only wrapped to `''`\r\n\r\n```js\r\nlet bool = true;  \r\nconsole.log(String(bool)); // \"true\"  \r\nbool = false;  \r\nconsole.log(String(bool)); // \"false\"  \r\nlet num = 42;  \r\nconsole.log(String(num));  // \"42\"\r\n```\r\n\r\nIf object is converted to string, then object will be wrapped to string in this way\r\n\r\n```js\r\nconsole.log(String([])); // \"\"  \r\nconsole.log(String([1,2,3])); // \"1,2,3\"  \r\nconsole.log(String({})); // \"[object Object]\"\r\n```\r\n\r\n2\\. **Implicit type conversion** (also known as coercion) is performed automatically by JavaScript when a value of one data type is used in a context that expects a different data type.\r\n\r\n**Implicit Type Conversion on Addition**\r\n\r\nIn case of boolean, it implicitly convert it to Number and then perform addition operation\r\n\r\n```js\r\nlet num = 42;  \r\nlet bool1 = true;  \r\nlet bool2 = false;  \r\nconsole.log(num + bool1); // 43  \r\nconsole.log(num + bool2); // 42\r\n```\r\n\r\nIn case of array and string, it simply convert both of them to string and then perform concatenation\r\n\r\n```js\r\nlet str = \"foo\";  \r\nlet num = 42;  \r\nconsole.log(str + num); // \"foo42\"\r\n```\r\n\r\n```js\r\nlet arr = [1, 2, 3];  \r\nlet num = 42;  \r\nconsole.log(arr + num); // \"1,2,342\"\r\n```\r\n\r\n**Implicit Type Conversion on Subtraction**\r\n\r\nIn case of boolean, it implicitly convert it to Number and then perform subtraction operation\r\n\r\n```js\r\nlet num = 42;  \r\nlet bool1 = true;  \r\nlet bool2 = false;  \r\nconsole.log(num - bool1); // 41  \r\nconsole.log(num - bool2); // 42\r\n```\r\n\r\nIn case of string, it implicitly convert it to Number and then perform subtraction operation\r\n\r\n```js\r\nlet str = \"7\";  \r\nlet num = 4;  \r\nconsole.log(str - num); // 3\r\n```\r\n\r\nIn case of non-numeric string, or array or object, it will result in NaN except one situation that array has only and only one Number.\r\n\r\n```js\r\nlet str = \"foo\";  \r\nconsole.log(str - 1); // NaN\r\n```\r\n\r\n```js\r\nlet arr = [1, 2, 3];  \r\nconsole.log(arr - 1); // NaNlet arr1 = [1];  \r\nconsole.log(arr1 - 1); // 0let obj = {name: \"John\"};  \r\nconsole.log(obj - 1); // NaN\r\n```\r\n\r\n**Implicit Type Conversion on Comparison**\r\n\r\nThe rules for type coercion in comparison operators is that JavaScript tries to convert the values to a type that makes sense for the comparison being made. In case of strict equality, implicit type conversion not happens, it simply return false.\r\n\r\n```js\r\nconsole.log('10' == 10); // true  \r\nconsole.log('10' == '10'); // true  \r\nconsole.log(true == 1); // true  \r\nconsole.log(false == 0); // true  \r\nconsole.log(null == undefined); // true  \r\nconsole.log('' == 0); // true  \r\nconsole.log([] == ''); // true  \r\nconsole.log([] == 0); // true  \r\nconsole.log([1, 2] == '1,2'); // true  \r\nconsole.log(NaN == NaN); // false\r\n```\r\n\r\nIn conclusion, this is how conversion happens in JavaScript. By understanding this, you can write predicted and efficient code."},{"id":"functions-in-js-named-anonymous","metadata":{"permalink":"/blog/functions-in-js-named-anonymous","editUrl":"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/7-functions-in-js-named-anonymous.md","source":"@site/blog/javascript/7-functions-in-js-named-anonymous.md","title":"Functions in JS: named, anonymous","description":"JavaScript is a programming language used mainly for creating interactive web pages. One of its most powerful features is the ability to create functions, which are reusable blocks of code that perform a specific task. In this blog post, we will discuss what functions are, how they work, and how to create and use them in JavaScript.","date":"2024-05-16T10:39:22.000Z","tags":[{"label":"javascript","permalink":"/blog/tags/javascript"}],"readingTime":4.84,"hasTruncateMarker":true,"authors":[{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"}],"frontMatter":{"slug":"functions-in-js-named-anonymous","title":"Functions in JS: named, anonymous","authors":{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"},"tags":["javascript"]},"unlisted":false,"prevItem":{"title":"TypeConversion in JS","permalink":"/blog/typeconversion-in-js"},"nextItem":{"title":"Array in JS","permalink":"/blog/array-in-js"}},"content":"JavaScript is a programming language used mainly for creating interactive web pages. One of its most powerful features is the ability to create functions, which are reusable blocks of code that perform a specific task. In this blog post, we will discuss what functions are, how they work, and how to create and use them in JavaScript.\r\n<!-- truncate -->\r\n\r\nWhat are Functions?\r\n===================\r\n\r\nFunctions are reusable blocks of code that perform a specific task. They take input in the form of arguments and return output in the form of a value. Functions can be used to perform a variety of tasks, from simple calculations to complex operations.\r\n\r\nCreating Functions in JavaScript\r\n================================\r\n\r\nThe simplest function in JavaScript will look like:\r\n\r\n```js\r\nfunction myFunction(){  \r\n\tconsole.log('Hello, I am a function');  \r\n}\r\n```\r\n\r\nTo execute the function we need to call the function:\r\n\r\n```js\r\n// calling to function  \r\nmyFunction(); // Hello, I am a function  \r\n// again calling the function  \r\nmyFunction(); // Hello, I am a function\r\n```\r\n\r\nFunction don’t only use for consoling some output or simple operations, you can also use function to return some value, like:\r\n\r\n```js\r\nfunction myFunction(){  \r\n\treturn 'Hello I am a function';  \r\n}  \r\nmyFunction() // no output  \r\nconsole.log(myFunction()) // Hello, I am a function\r\n```\r\n\r\nYou can also pass parameter to function\r\n\r\n```js\r\nfunction greet(name) {  \r\n  console.log(`Hello, ${name}!`);  \r\n}  \r\ngreet(\"John\"); // \"Hello, John!\"  \r\ngreet(\"Jane\"); // \"Hello, Jane!\"\r\n```\r\n\r\nYou can also pass multiple parameters to a JavaScript function, like this:\r\n\r\n```js\r\nfunction add(a, b) {  \r\n  return a + b;  \r\n}  \r\nconsole.log(add(2, 3)); // 5  \r\nconsole.log(add(4, 5)); // 9\r\n```\r\n\r\nRest parameters allow you to pass an arbitrary number of arguments to a function as an array. You can define a rest parameter using three dots (…) followed by the parameter name.\r\n\r\nFor example, consider the following code that calculates the sum of an arbitrary number of arguments using a rest parameter:\r\n\r\n```js\r\nfunction sum(...nums) {  \r\n  return nums.reduce((total, num) => total + num);  \r\n}  \r\nconsole.log(sum(1, 2, 3, 4, 5)); // Output: 15  \r\nconsole.log(sum(10, 20)); // Output: 30\r\n```\r\n\r\nFunctions can also return objects or arrays or any complex datatype\r\n\r\n```js\r\nfunction createPerson(name, age) {  \r\n  return {  \r\n    name: name,  \r\n    age: age  \r\n  };  \r\n}  \r\nlet person1 = createPerson(\"John\", 30);  \r\nlet person2 = createPerson(\"Jane\", 25);  \r\nconsole.log(person1); // outputs {name: \"John\", age: 30}  \r\nconsole.log(person2); // outputs {name: \"Jane\", age: 25}\r\n```\r\n\r\nFunctions as First-Class Citizens\r\n=================================\r\n\r\nIn JavaScript, functions are considered “first-class citizens”, which means that they are treated like any other value or data type, such as strings or numbers.\r\n\r\nThis means that functions can be:\r\n\r\n1.  Assigned to variables:\r\n\r\n```js\r\nconst myFunction = function() {  \r\n  console.log(\"Hello world!\");  \r\n};\r\n```\r\n\r\n1.  Passed as arguments to other functions:\r\n\r\n```js\r\nfunction execute(func) {  \r\n  func();  \r\n}  \r\nexecute(function() {  \r\n  console.log(\"Hello world!\");  \r\n});\r\n```\r\n\r\n1.  Returned as values from functions:\r\n\r\n```js\r\nfunction createFunction() {  \r\n  return function() {  \r\n    console.log(\"Hello world!\");  \r\n  };  \r\n}  \r\nconst myFunction = createFunction();  \r\nmyFunction(); // Hello World  \r\ncreateFunction()(); // Hello World\r\n```\r\n\r\nBecause of this first-class status, functions in JavaScript can be used to create powerful abstractions and higher-order functions. This is what makes JavaScript a powerful functional programming language.\r\n\r\nNamed vs. Anonymous Functions\r\n=============================\r\n\r\nIn JavaScript, there are two types of functions: named and anonymous.\r\n\r\nNamed Functions\r\n===============\r\n\r\nNamed functions have a name identifier and can be defined using the `**function**` keyword.\r\n\r\n```js\r\nfunction namedFunction(param1, param2) {  \r\n  // function body  \r\n}\r\n```\r\n\r\nNamed functions are hoisted at the top of the scope.\r\n\r\nAnonymous Functions\r\n===================\r\n\r\nAnonymous functions do not have a name identifier, but can be assigned to a variable or passed as an argument to another function. They are also defined using the `**function**` keyword.\r\n\r\n```js\r\nconst anonymousFunction = function(param1, param2) {  \r\n  // function body  \r\n};\r\n```\r\n\r\nAnonymous functions are not hoisted.\r\n\r\nArrow Functions\r\n===============\r\n\r\nArrow functions are a concise way to define a function and are defined using the `**=>**` syntax. They are similar to anonymous functions but have a shorter syntax and do not have their own `**this**` keyword and instead inherit it from their lexical scope.\r\n\r\n```js\r\nconst arrowFunction = (param1, param2) => {  \r\n  // function body  \r\n};\r\n```\r\n\r\nArrow functions are not hoisted.\r\n\r\nProperties of JS Functions\r\n==========================\r\n\r\n1.  Functions are objects: In JavaScript, functions are actually objects. This means that they can have properties and methods just like any other object.\\\\\r\n\r\n```js\r\nfunction myFunction() {  \r\n  console.log(\"Hello, World!\");  \r\n}  \r\n// Functions are objects and can have properties and methods  \r\nmyFunction.myProperty = \"This is a property of myFunction\";  \r\nmyFunction.myMethod = function() {  \r\n  console.log(\"This is a method of myFunction\");  \r\n}  \r\n// Access the property and method of myFunction  \r\nconsole.log(myFunction.myProperty); // \"This is a property of myFunction\"  \r\nmyFunction.myMethod(); // \"This is a method of myFunction\"\r\n```\r\n\r\n2\\. Functions can be nested: In JavaScript, functions can be nested within other functions. This allows for the creation of closures, which are powerful tools for maintaining state and creating private variables.\r\n\r\n```js\r\nfunction outerFunction() {  \r\n  const outerVar = \"I am defined in the outer function\";  \r\n  function innerFunction() {  \r\n    const innerVar = \"I am defined in the inner function\";  \r\n    console.log(innerVar);  \r\n    console.log(outerVar);  \r\n  }  \r\n  innerFunction();  \r\n}  \r\nouterFunction();   \r\n// I am defined in the outer function  \r\n// I am defined in the inner function\r\n```\r\n\r\n3\\. Functions can have default parameters: Starting with ES6, JavaScript allows for the use of default function parameters. This means that you can specify default values for parameters that are not passed in when the function is called.\r\n\r\n```js\r\nfunction greet(name = \"World\") {  \r\n  console.log(`Hello, ${name}!`);  \r\n}  \r\ngreet(); // \"Hello, World!\"  \r\ngreet(\"John\"); // \"Hello, John!\"\r\n```\r\n\r\nConclusion\r\n==========\r\n\r\nIn this blog post, we have discussed what functions are, how to create and use them, and the different types of functions in JavaScript. Functions are an essential part of JavaScript programming and are used extensively in web development. By understanding how functions work, you can write more efficient and maintainable code."},{"id":"array-in-js","metadata":{"permalink":"/blog/array-in-js","editUrl":"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/8-array-in-js.md","source":"@site/blog/javascript/8-array-in-js.md","title":"Array in JS","description":"JavaScript is an incredibly popular programming language and one of the reasons it is so popular is because of the versatility of arrays in JavaScript. Arrays in JavaScript are used to store multiple values in a single variable.","date":"2024-05-16T10:39:22.000Z","tags":[{"label":"javascript","permalink":"/blog/tags/javascript"}],"readingTime":5.005,"hasTruncateMarker":true,"authors":[{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"}],"frontMatter":{"slug":"array-in-js","title":"Array in JS","authors":{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"},"tags":["javascript"]},"unlisted":false,"prevItem":{"title":"Functions in JS: named, anonymous","permalink":"/blog/functions-in-js-named-anonymous"},"nextItem":{"title":"Object in JS","permalink":"/blog/object-in-js"}},"content":"JavaScript is an incredibly popular programming language and one of the reasons it is so popular is because of the versatility of arrays in JavaScript. Arrays in JavaScript are used to store multiple values in a single variable.\r\n<!-- truncate -->\r\n\r\nCreating an Array\r\n=================\r\n\r\nThere are two ways to create an array in JavaScript. The first method is to use the Array() constructor. Here is an example:\r\n\r\n```js\r\nlet fruits = new Array(\"apple\", \"banana\", \"orange\");\r\n```\r\n\r\nThe second method is to use array literal notation. Here is an example:\r\n\r\n```js\r\nlet fruits = [\"apple\", \"banana\", \"orange\"];\r\n```\r\n\r\nAccessing Array Elements\r\n========================\r\n\r\nYou can access individual elements of an array by referring to the index number. Here is an example:\r\n\r\n```js\r\nlet fruits = [\"apple\", \"banana\", \"orange\"];  \r\nconsole.log(fruits[0]); // \"apple\"\r\n```\r\n\r\nModifying Array Elements\r\n========================\r\n\r\nYou can modify elements of an array by referring to the index number and assigning a new value. Here is an example:\r\n\r\n```js\r\nlet fruits = [\"apple\", \"banana\", \"orange\"];  \r\nfruits[0] = \"pear\";  \r\nconsole.log(fruits); // [\"pear\", \"banana\", \"orange\"]\r\n```\r\n\r\nSpread Syntax\r\n=============\r\n\r\nSpread syntax allows you to spread an array or object into another array or object. You can use the spread syntax by using three dots (…) before the array or object name.\r\n\r\nFor example, consider the following code that concatenates two arrays using spread syntax:\r\n\r\n```js\r\nconst arr1 = [1, 2, 3];  \r\nconst arr2 = [4, 5, 6];  \r\nconst arr3 = [...arr1, ...arr2];  \r\nconsole.log(arr3); // Output: [1, 2, 3, 4, 5, 6]\r\n```\r\n\r\nYou can also use spread syntax to create a copy of an array or object:\r\n\r\n```js\r\njavascriptCopy code  \r\nconst arr1 = [1, 2, 3];  \r\nconst arr2 = [...arr1];  \r\nconsole.log(arr2); // Output: [1, 2, 3]\r\n```\r\n\r\ntypeof Array\r\n============\r\n\r\nIn JavaScript, the `**typeof**` operator will return \"object\" for an array. This is because arrays in JavaScript are a type of object.\r\n\r\nFor example:\r\n\r\n```js\r\nconst myArray = [1, 2, 3];  \r\nconsole.log(typeof myArray); // \"object\"\r\n```\r\n\r\nThis can be surprising at first, but it’s important to remember that arrays in JavaScript are implemented as objects with integer-based keys that are automatically updated when elements are added or removed.\r\n\r\nTo check if a variable is an array, you can use the `**Array.isArray()**` method instead. This method returns `**true**` if the variable is an array and `**false**` otherwise. For example:\r\n\r\n```js\r\nconst myArray = [1, 2, 3];  \r\nconsole.log(Array.isArray(myArray)); // true\r\n```\r\n\r\nArray Methods\r\n=============\r\n\r\nJavaScript provides several methods for working with arrays. Here are a few of the most common methods:\r\n\r\npush()\r\n======\r\n\r\nThe push() method adds one or more elements to the end of an array. Here is an example:\r\n\r\n```js\r\nlet fruits = [\"apple\", \"banana\", \"orange\"];  \r\nfruits.push(\"pear\");  \r\nconsole.log(fruits); // [\"apple\", \"banana\", \"orange\", \"pear\"]\r\n```\r\n\r\npop()\r\n=====\r\n\r\nThe pop() method removes the last element from an array. Here is an example:\r\n\r\n```js\r\nlet fruits = [\"apple\", \"banana\", \"orange\"];  \r\nfruits.pop();  \r\nconsole.log(fruits); // [\"apple\", \"banana\"]\r\n```\r\n\r\nshift()\r\n=======\r\n\r\nThe shift() method removes the first element from an array. Here is an example:\r\n\r\n```js\r\nlet fruits = [\"apple\", \"banana\", \"orange\"];  \r\nfruits.shift();  \r\nconsole.log(fruits); // [\"banana\", \"orange\"]\r\n```\r\n\r\nunshift()\r\n=========\r\n\r\nThe unshift() method adds one or more elements to the beginning of an array. Here is an example:\r\n\r\n```js\r\nlet fruits = [\"apple\", \"banana\", \"orange\"];  \r\nfruits.unshift(\"pear\");  \r\nconsole.log(fruits); // [\"pear\", \"apple\", \"banana\", \"orange\"]\r\n```\r\n\r\nslice()\r\n=======\r\n\r\nThe slice() method returns a new array that contains a portion of the original array. Here is an example:\r\n\r\n```js\r\nlet fruits = [\"apple\", \"banana\", \"orange\", \"pear\"];  \r\nlet newFruits = fruits.slice(1, 3);  \r\nconsole.log(newFruits); // [\"banana\", \"orange\"]\r\n```\r\n\r\nLoops of Array in JavaScript\r\n============================\r\n\r\nOne of the most important features of arrays in JavaScript is the ability to loop through the elements of an array. There are several ways to loop through an array in JavaScript.\r\n\r\nFor Loop\r\n========\r\n\r\nThe for loop is the most common way to loop through an array in JavaScript. Here is an example:\r\n\r\n```js\r\nlet fruits = [\"apple\", \"banana\", \"orange\", \"pear\"];  \r\nfor (let i = 0; i < fruits.length; i++) {  \r\n  console.log(fruits[i]);  \r\n}\r\n```\r\n\r\nforEach() Method\r\n================\r\n\r\nThe forEach() method is a built-in method of arrays in JavaScript that provides a convenient way to loop through the elements of an array. Here is an example:\r\n\r\n```js\r\nlet fruits = [\"apple\", \"banana\", \"orange\", \"pear\"];  \r\nfruits.forEach(function(fruit) {  \r\n  console.log(fruit);  \r\n});\r\n```\r\n\r\nFor…of Loop\r\n===========\r\n\r\nThe for…of loop is a newer feature of JavaScript that provides a simpler way to loop through arrays. Here is an example:\r\n\r\n```js\r\nlet fruits = [\"apple\", \"banana\", \"orange\", \"pear\"];  \r\nfor (let fruit of fruits) {  \r\n  console.log(fruit);  \r\n}\r\n```\r\n\r\nIterables\r\n=========\r\n\r\nUsing loops, we can easily perform operations on each element of an array, such as displaying the elements or modifying them.\r\n\r\nmap() Method\r\n============\r\n\r\nThe map() method is used to create a new array by applying a function to each element of an existing array. Here is an example:\r\n\r\n```js\r\nlet numbers = [1, 2, 3, 4, 5];  \r\nlet doubledNumbers = numbers.map(function(number) {  \r\n  return number * 2;  \r\n});  \r\nconsole.log(doubledNumbers); // [2, 4, 6, 8, 10]\r\n```\r\n\r\nreduce() Method\r\n===============\r\n\r\nThe reduce() method is used to reduce an array to a single value by applying a function to each element of the array. Here is an example:\r\n\r\n```js\r\nlet numbers = [1, 2, 3, 4, 5];  \r\nlet sum = numbers.reduce(function(accumulator, currentValue) {  \r\n  return accumulator + currentValue;  \r\n});  \r\nconsole.log(sum); // 15\r\n```\r\n\r\nfilter() Method\r\n===============\r\n\r\nThe filter() method is used to create a new array that contains only the elements of an existing array that meet a certain condition. Here is an example:\r\n\r\n```js\r\nlet numbers = [1, 2, 3, 4, 5];  \r\nlet evenNumbers = numbers.filter(function(number) {  \r\n  return number % 2 === 0;  \r\n});  \r\nconsole.log(evenNumbers); // [2, 4]\r\n```\r\n\r\nUsing the map(), reduce(), and filter() methods, we can easily manipulate and transform arrays in JavaScript.\r\n\r\nConclusion\r\n==========\r\n\r\nArrays are an essential tool in JavaScript programming. They are used to store multiple values in a single variable and provide a convenient way to access and modify those values. With the built-in methods provided by JavaScript, working with arrays is easy and efficient."},{"id":"object-in-js","metadata":{"permalink":"/blog/object-in-js","editUrl":"https://github.com/sonnetjs/sonnetjs.github.io/tree/main/blog/javascript/9-object-in-js.md","source":"@site/blog/javascript/9-object-in-js.md","title":"Object in JS","description":"In JavaScript, an object is a collection of key-value pairs, where the keys are strings (or symbols) and the values can be of any type. It is an unordered data structure that can hold primitive data types, arrays, and even functions. Objects are used to represent real-world entities, and they provide a way to organize and store related data.","date":"2024-05-16T10:39:22.000Z","tags":[{"label":"javascript","permalink":"/blog/tags/javascript"}],"readingTime":9.12,"hasTruncateMarker":true,"authors":[{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"}],"frontMatter":{"slug":"object-in-js","title":"Object in JS","authors":{"name":"Talha Mujahid","title":"Software Engineer","url":"https://github.com/htmujahid","image_url":"https://avatars.githubusercontent.com/u/58030954?v=4","imageURL":"https://avatars.githubusercontent.com/u/58030954?v=4"},"tags":["javascript"]},"unlisted":false,"prevItem":{"title":"Array in JS","permalink":"/blog/array-in-js"}},"content":"In JavaScript, an object is a collection of key-value pairs, where the keys are strings (or symbols) and the values can be of any type. It is an unordered data structure that can hold primitive data types, arrays, and even functions. Objects are used to represent real-world entities, and they provide a way to organize and store related data.\r\n<!-- truncate -->\r\n\r\nCreating Objects in JavaScript\r\n==============================\r\n\r\nThere are several ways to create objects in JavaScript:\r\n\r\nObject Literals\r\n===============\r\n\r\nThe most common way to create an object is by using an object literal. An object literal is a comma-separated list of key-value pairs enclosed in curly braces. For example:\r\n\r\n```js\r\nlet person = {  \r\n  name: \"John\",  \r\n  age: 30,  \r\n  address: {  \r\n    street: \"123 Main St\",  \r\n    city: \"New York\",  \r\n    state: \"NY\"  \r\n  }  \r\n};\r\n```\r\n\r\nUsing the Object Constructor\r\n============================\r\n\r\nAnother way to create objects is by using the Object constructor. This method is less commonly used but can be useful in certain situations. For example:\r\n\r\n```js\r\nlet person = new Object();  \r\nperson.name = \"John\";  \r\nperson.age = 30;  \r\nperson.address = {  \r\n  street: \"123 Main St\",  \r\n  city: \"New York\",  \r\n  state: \"NY\"  \r\n};\r\n```\r\n\r\nUsing Object.create()\r\n=====================\r\n\r\nA third way to create objects is by using the Object.create() method. This method creates a new object and sets its prototype to an existing object. For example:\r\n\r\n```js\r\nlet person = Object.create(null);  \r\nperson.name = \"John\";  \r\nperson.age = 30;  \r\nperson.address = {  \r\n  street: \"123 Main St\",  \r\n  city: \"New York\",  \r\n  state: \"NY\"  \r\n};\r\n```\r\n\r\nAccessing Object Properties\r\n===========================\r\n\r\nYou can access object properties using dot notation or bracket notation. For example:\r\n\r\n```js\r\nlet person = {  \r\n  name: \"John\",  \r\n  age: 30  \r\n};  \r\nconsole.log(person.name); // \"John\"  \r\nconsole.log(person[\"age\"]); // 30\r\n```\r\n\r\nModifying Object Properties\r\n===========================\r\n\r\nYou can modify object properties by simply assigning a new value to them. For example:\r\n\r\n```js\r\nlet person = {  \r\n  name: \"John\",  \r\n  age: 30  \r\n};  \r\nperson.age = 40;  \r\nconsole.log(person.age); // 40\r\n```\r\n\r\nAdding Object Properties\r\n========================\r\n\r\nYou can add new properties to an object by simply assigning a value to a new key. For example:\r\n\r\n```js\r\nlet person = {  \r\n  name: \"John\",  \r\n  age: 30  \r\n};  \r\nperson.address = {  \r\n  street: \"123 Main St\",  \r\n  city: \"New York\",  \r\n  state: \"NY\"  \r\n};  \r\nconsole.log(person.address); // { street: \"123 Main St\", city: \"New York\", state: \"NY\" }\r\n```\r\n\r\nCharacteristics of Keys and Values in JS Objects\r\n================================================\r\n\r\nThe characteristics of keys and values in JavaScript objects are as follows:\r\n\r\n1.  Keys must be unique within an object. If you try to add a new property with an existing key, the value of the existing property will be overwritten with the new value.\r\n2.  Keys are always converted to strings. If you use a non-string value as a key, it will be automatically converted to a string using the `**toString()**` method.\r\n3.  Values can be of any type, including strings, numbers, booleans, objects, arrays, and functions.\r\n4.  Values can be accessed using dot notation (`**object.property**`) or bracket notation (`**object[\"property\"]**`). Dot notation can only be used if the property name is a valid identifier (i.e., it does not contain spaces or special characters).\r\n5.  Values can be added or modified at any time by assigning a new value to a property: `**object.property = value**` or `**object[\"property\"] = value**`.\r\n6.  Values can also be removed using the `**delete**` operator: `**delete object.property**` or `**delete object[\"property\"]**`.\r\n7.  In JavaScript, it is generally not recommended to use spaces in the name of a key in an object. While it is possible to use spaces in key names using bracket notation, it can make it harder to work with the object, as you would always have to use bracket notation to access the property.\r\n\r\nFor example, let’s say you have an object with a key called “first name” and you try to access it using dot notation:\r\n\r\n```\r\nconst person = {  \r\n  \"first name\": \"John\",  \r\n  age: 30  \r\n};  \r\nconsole.log(person.first name); // Outputs: undefined\r\n```\r\n\r\nThis code would result in an error because dot notation does not allow for spaces in the property name. Instead, you would have to use bracket notation to access the “first name” property:\r\n\r\n```\r\nconsole.log(person[\"first name\"]); // Outputs: \"John\"\r\n```\r\n\r\nThis can make the code more difficult to read and can introduce errors if you forget to use bracket notation when accessing the property.\r\n\r\nIt is generally recommended to use camelCase or snake_case for key names in JavaScript objects, as they are easier to read and less error-prone.\r\n\r\nfor…in loop\r\n===========\r\n\r\nThe for…in loop is a useful tool for iterating over an object’s properties. This loop allows you to loop through all of the object’s properties and perform some action on each one. For example:\r\n\r\n```js\r\nlet person = {  \r\n  name: \"John\",  \r\n  age: 30,  \r\n  address: {  \r\n    street: \"123 Main St\",  \r\n    city: \"New York\",  \r\n    state: \"NY\"  \r\n  }  \r\n};  \r\nfor (let prop in person) {  \r\n  console.log(prop + \": \" + person[prop]);  \r\n}  \r\n// Output:  \r\n// name: John  \r\n// age: 30  \r\n// address: [object Object]\r\n```\r\n\r\nObject Reference\r\n================\r\n\r\nWhen you create two empty objects in JavaScript, they are not equal to each other, even though they are both objects.\r\n\r\nFor example:\r\n\r\n```js\r\nconst person1 = {};  \r\nconst person2 = {};  \r\nconsole.log(person1 == person2); // false\r\n```\r\n\r\nThis is because `**person1**` and `**person2**` are both references to different objects in memory, even though the objects themselves have no properties or values.\r\n\r\nSo, objects are reference types, which means that when you assign an object to a variable or pass it as an argument to a function, you are actually passing a reference to the object in memory, rather than creating a new copy of the object.\r\n\r\nHere’s an example of how object references work in JavaScript:\r\n\r\n```js\r\nconst person1 = { name: \"John\", age: 30 };  \r\nconst person2 = person1;  \r\n\r\n```\r\n\r\nTo make a copy of an object in JavaScript, you can use the spread operator or the `**Object.assign()**` method:\r\n\r\n```js\r\n// Using the spread operator  \r\nconst person1 = { name: \"John\", age: 30 };  \r\nconst person2 = { ...person1 };  \r\nperson2.age = 31;  \r\nconsole.log(person1.age); // 30\r\n```\r\n\r\n`Object.assign()` works in this way:\r\n\r\n```js\r\nconst user = {};  \r\n// Using Object.assign() to add a \"name\" property to the \"user\" object  \r\nObject.assign(user, { name: \"john\" });  \r\nconsole.log(user); // { name: \"john\" }\r\n```\r\n\r\n`Object.assign` can also be used to copy an object:\r\n\r\n```js\r\n// Using Object.assign()  \r\nconst person3 = { name: \"John\", age: 30 };  \r\nconst person4 = Object.assign({}, person3);  \r\nperson4.age = 31;  \r\nconsole.log(person3.age); // 30\r\n```\r\n\r\nGarbage Collection\r\n==================\r\n\r\nGarbage collection is the process by which JavaScript automatically frees up memory that is no longer being used by an object. When an object is created, it is allocated a block of memory on the heap. When the object is no longer needed, the memory is freed up so that it can be used by other objects.\r\n\r\nJavaScript uses a form of garbage collection called reference counting. This means that each object keeps track of how many other objects are referencing it. When the reference count drops to zero, the object is no longer needed and its memory can be freed up.\r\n\r\nWhile garbage collection is a useful feature of JavaScript, it can also have some downsides. For example, managing memory can be slower than in other languages, as the garbage collector has to constantly monitor the reference counts of objects. Additionally, the garbage collector can sometimes be too aggressive, causing performance issues in some cases.\r\n\r\nDespite these limitations, garbage collection is still an important feature of JavaScript that helps developers to write more efficient and reliable code.\r\n\r\n```js\r\n// user is reference to object  \r\nlet user = {  \r\n\tname: \"John\"  \r\n}  \r\n// now reference is overridden  \r\nuser = null;  \r\n// there is no variable pointing to {name: \"John\"}, it will be in garbage collection\r\n```\r\n\r\nOptional Chaining\r\n=================\r\n\r\nOptional chaining is a feature in JavaScript that allows you to safely access deeply nested properties of an object without worrying about the intermediate properties being `**null**` or `**undefined**`.\r\n\r\n```js\r\nconst user = {  \r\n  name: \"John\",  \r\n  address: {  \r\n    street: \"123 Main St\",  \r\n    city: \"Anytown\",  \r\n    state: \"CA\",  \r\n    zip: \"12345\"  \r\n  }  \r\n};  \r\n// Using optional chaining to access nested properties  \r\nconst zipCode = user?.address?.zip; // \"12345\"  \r\n// Trying to access a non-existent property with optional chaining  \r\nconst phone = user?.contact?.phone; // undefined\r\n```\r\n\r\nSymbol Type\r\n===========\r\n\r\nIn JavaScript, `**Symbol**` is a primitive data type that is used to create unique identifiers for objects. Symbols are created using the `**Symbol()**` constructor function, which returns a new, unique symbol each time it is called.\r\n\r\nHere is an example of creating and using symbols with an object:\r\n\r\n```js\r\nconst name = Symbol('name');  \r\nconst age = Symbol('age');  \r\nconst person = {  \r\n  [name]: 'John',  \r\n  [age]: 30,  \r\n  gender: 'male'  \r\n};  \r\nconsole.log(person[name]); // \"John\"  \r\nconsole.log(person[age]); // 30  \r\nconsole.log(person.gender); // \"male\"\r\n```\r\n\r\nWe can access the values of the symbol properties using the square bracket notation with the symbol as the key. Note that we cannot access the symbol properties using dot notation, as symbols are not valid property names in that syntax.\r\n\r\nSymbols are often used to create private or hidden properties in objects, as they cannot be accessed or modified from outside the object. They are also useful for creating non-colliding property names in cases where multiple objects might share the same key name.\r\n\r\nSymbol.iterator\r\n===============\r\n\r\n`**Symbol.iterator**` is a built-in symbol in JavaScript that is used to define the default iterator for an object. An iterator is an object that provides a way to iterate over the elements of a collection one at a time.\r\n\r\nTo use `**Symbol.iterator**`, you define a method on an object that returns an iterator object. This method is called when the object is used in a `**for...of**` loop or when the `**next()**` method is called on the iterator object.\r\n\r\nHere is an example of using `**Symbol.iterator**` to define an iterator for an array:\r\n\r\n```js\r\nconst arr = [1, 2, 3];  \r\narr[Symbol.iterator] = function() {  \r\n  let i = 0;  \r\n  return {  \r\n    next: () => {  \r\n      if (i < this.length) {  \r\n        return { value: this[i++], done: false };  \r\n      } else {  \r\n        return { done: true };  \r\n      }  \r\n    }  \r\n  };  \r\n};  \r\nfor (const num of arr) {  \r\n  console.log(num);  \r\n}\r\n```\r\n\r\nNote that the `**Symbol.iterator**` method can be defined on any object, not just arrays. This allows you to define custom iteration behavior for any object that you create.\r\n\r\n```js\r\nconst obj = { from: 1, to: 3 };  \r\nobj[Symbol.iterator] = function() {  \r\n  let current = this.from;  \r\n  const last = this.to;  \r\n   return {  \r\n    next: () => {  \r\n      if (current <= last) {  \r\n        return { value: current++, done: false };  \r\n      } else {  \r\n        return { done: true };  \r\n      }  \r\n    }  \r\n  };  \r\n};  \r\nconst arr = [...obj]; // [1, 2, 3]\r\n```\r\n\r\nConclusion\r\n==========\r\n\r\nIn JavaScript, objects are a powerful data structure that can be used to represent complex entities. They provide a way to organize and store related data, and can be easily accessed, modified, and extended. Understanding how to create and work with objects is an essential skill for any JavaScript developer."}]}}